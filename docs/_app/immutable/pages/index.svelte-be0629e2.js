import{S as Mt,i as xt,s as zt,l as r,u as h,a as N,x as he,m as i,p as o,v as c,h as s,c as M,y as ce,q as g,b as B,H as t,z as pe,L as v,f as J,t as se,C as fe,M as Lt,N as Zt,O as jt,n as Ct,P as Jt,Q as Kt,R as Bt,T as Vt,U as gt,V as bt,W as Ut,r as Ot,X as Oe,d as ea,Y as Dt,Z as Rt,g as ta,_ as vt}from"../chunks/index-ca49edcf.js";import{Q as Qt}from"../chunks/Qubit-bb2ae073.js";import{H as ot,Q as aa,a as na,s as Gt}from"../chunks/QuantumQubit-ab753e9a.js";import{m as P,a as ct,d as sa,s as ra,b as ia,c as It,p as Nt}from"../chunks/index-ba7e8b36.js";import{s as yt}from"../chunks/qgates-46947dcc.js";const oa='<a href="https://en.wikipedia.org/wiki/Operator_(physics)"><h3>Operator (physics)</h3></a><p>In physics, an <b>operator</b> is a function over a space of physical states onto another space of physical states. The simplest example of the utility of operators is the study of symmetry. Because of this, they are very useful tools in classical mechanics. Operators are even more important in quantum mechanics, where they form an intrinsic part of the formulation of the theory.</p>',la=`<a href="https://en.wikipedia.org/wiki/Quantum_circuit"><h3>Quantum circuit</h3></a><p>In quantum information theory, a <b>quantum circuit</b> is a model for quantum computation, similar to classical circuits, in which a computation is a sequence of quantum gates, measurements, initializations of qubits to known values, and possibly other actions. The minimum set of actions that a circuit needs to be able to perform on the qubits to enable quantum computation is known as DiVincenzo's criteria.</p>`,ua='<a href="https://en.wikipedia.org/wiki/Quantum_logic_gate"><h3>Quantum logic gate</h3></a><p>In quantum computing and specifically the quantum circuit model of computation, a <b>quantum logic gate</b> is a basic quantum circuit operating on a small number of qubits. They are the building blocks of quantum circuits, like classical logic gates are for conventional digital circuits.</p>';function ma(a){let e;return{c(){e=h("Quantum operators")},l(n){e=c(n,"Quantum operators")},m(n,u){B(n,e,u)},d(n){n&&s(e)}}}function ha(a){let e;return{c(){e=h("quantum circuit")},l(n){e=c(n,"quantum circuit")},m(n,u){B(n,e,u)},d(n){n&&s(e)}}}function ca(a){let e;return{c(){e=h("quantum logic gates")},l(n){e=c(n,"quantum logic gates")},m(n,u){B(n,e,u)},d(n){n&&s(e)}}}function pa(a){let e,n,u,d,p,$,q,z,_,b,S,l,T,L,G=P("|\\psi\\rangle = \\begin{bmatrix}\\alpha\\\\\\beta\\end{bmatrix},")+"",re,K,ee=P("U")+"",F,k,Ae=P("|\\psi\\rangle")+"",Se,H,He=P("U|\\psi\\rangle")+"",te,Ee,U=P("\\displaystyle H = \\frac{1}{\\sqrt{2}} \\cdot \\begin{bmatrix}1&1 \\\\ 1&-1\\end{bmatrix}")+"",Y,be,et=P("\\begin{bmatrix}1+0i\\\\0+0i\\end{bmatrix}")+"",C,D,Ie=P("\\begin{bmatrix}\\frac{1}{\\sqrt{2}}+0i\\\\\\frac{1}{\\sqrt{2}}+0i\\end{bmatrix}")+"",ie,de,X,Re,ae,_e,Pe;return p=new ot({props:{hovertext:oa,$$slots:{default:[ma]},$$scope:{ctx:a}}}),q=new ot({props:{hovertext:la,$$slots:{default:[ha]},$$scope:{ctx:a}}}),_=new ot({props:{hovertext:ua,$$slots:{default:[ca]},$$scope:{ctx:a}}}),{c(){e=r("h2"),n=h("Quantum gates"),u=N(),d=r("p"),he(p.$$.fragment),$=h(" are functions that act on the state of a quantum system. Quantum algorithms are sequences of specific quantum operators that modify the state of single or multiple qubits. The physical device that implements quantum algorithms is called a "),he(q.$$.fragment),z=h(", the building blocks of which are "),he(_.$$.fragment),b=h(" that correspond to the individual operators in the sequence."),S=N(),l=r("p"),T=h("For each quantum operator, there's a corresponding matrix and the state of the qubit can be written as a vector "),L=r("span"),re=h(" so the algebraic representation of an operator "),K=r("span"),F=h(" acting on the state "),k=r("span"),Se=h(" is essentially the matrix multiplication "),H=r("span"),te=h(". For example, the Hadamard gate is represented by the "),Ee=r("span"),Y=h(" matrix, which means it can transform a qubit from a state of "),be=r("span"),C=h(" to "),D=r("span"),ie=h(". This is a slightly more complicated case of "),de=r("a"),X=h("thinking of matrices as linear transformations"),Re=h(" - as complex numbers are involved - but the basic principles remain the same, and hopefully one can gather a decent understanding by tinkering with the Bloch sphere and its transformations below."),this.h()},l(E){e=i(E,"H2",{});var x=o(e);n=c(x,"Quantum gates"),x.forEach(s),u=M(E),d=i(E,"P",{});var I=o(d);ce(p.$$.fragment,I),$=c(I," are functions that act on the state of a quantum system. Quantum algorithms are sequences of specific quantum operators that modify the state of single or multiple qubits. The physical device that implements quantum algorithms is called a "),ce(q.$$.fragment,I),z=c(I,", the building blocks of which are "),ce(_.$$.fragment,I),b=c(I," that correspond to the individual operators in the sequence."),I.forEach(s),S=M(E),l=i(E,"P",{});var A=o(l);T=c(A,"For each quantum operator, there's a corresponding matrix and the state of the qubit can be written as a vector "),L=i(A,"SPAN",{});var W=o(L);W.forEach(s),re=c(A," so the algebraic representation of an operator "),K=i(A,"SPAN",{});var ze=o(K);ze.forEach(s),F=c(A," acting on the state "),k=i(A,"SPAN",{});var Ne=o(k);Ne.forEach(s),Se=c(A," is essentially the matrix multiplication "),H=i(A,"SPAN",{});var ge=o(H);ge.forEach(s),te=c(A,". For example, the Hadamard gate is represented by the "),Ee=i(A,"SPAN",{});var Ge=o(Ee);Ge.forEach(s),Y=c(A," matrix, which means it can transform a qubit from a state of "),be=i(A,"SPAN",{});var Z=o(be);Z.forEach(s),C=c(A," to "),D=i(A,"SPAN",{});var j=o(D);j.forEach(s),ie=c(A,". This is a slightly more complicated case of "),de=i(A,"A",{href:!0});var Me=o(de);X=c(Me,"thinking of matrices as linear transformations"),Me.forEach(s),Re=c(A," - as complex numbers are involved - but the basic principles remain the same, and hopefully one can gather a decent understanding by tinkering with the Bloch sphere and its transformations below."),A.forEach(s),this.h()},h(){g(de,"href","https://www.youtube.com/watch?v=kYB8IZa5AuE")},m(E,x){B(E,e,x),t(e,n),B(E,u,x),B(E,d,x),pe(p,d,null),t(d,$),pe(q,d,null),t(d,z),pe(_,d,null),t(d,b),B(E,S,x),B(E,l,x),t(l,T),t(l,L),L.innerHTML=G,t(l,re),t(l,K),K.innerHTML=ee,t(l,F),t(l,k),k.innerHTML=Ae,t(l,Se),t(l,H),H.innerHTML=He,t(l,te),t(l,Ee),Ee.innerHTML=U,t(l,Y),t(l,be),be.innerHTML=et,t(l,C),t(l,D),D.innerHTML=Ie,t(l,ie),t(l,de),t(de,X),t(l,Re),ae=!0,_e||(Pe=[v(L,"mouseenter",a[0]),v(K,"mouseenter",a[1]),v(k,"mouseenter",a[2]),v(H,"mouseenter",a[3]),v(Ee,"mouseenter",a[4]),v(be,"mouseenter",a[5]),v(D,"mouseenter",a[6])],_e=!0)},p(E,[x]){const I={};x&128&&(I.$$scope={dirty:x,ctx:E}),p.$set(I);const A={};x&128&&(A.$$scope={dirty:x,ctx:E}),q.$set(A);const W={};x&128&&(W.$$scope={dirty:x,ctx:E}),_.$set(W)},i(E){ae||(J(p.$$.fragment,E),J(q.$$.fragment,E),J(_.$$.fragment,E),ae=!0)},o(E){se(p.$$.fragment,E),se(q.$$.fragment,E),se(_.$$.fragment,E),ae=!1},d(E){E&&s(e),E&&s(u),E&&s(d),fe(p),fe(q),fe(_),E&&s(S),E&&s(l),_e=!1,Lt(Pe)}}}function it(a){console.log(a)}function fa(a){return[()=>it(["m","t","b","x","a","\\beta","\\psi","r","\\alpha"]),()=>it(["U"]),()=>it(["\\psi"]),()=>it(["U","\\psi"]),()=>it(["m","H","t","b","x","a","r"]),()=>it(["m","t","b","x","a","r"]),()=>it(["m","t","b","x","a","r"])]}class da extends Mt{constructor(e){super(),xt(this,e,fa,pa,zt,{})}}const _a='<a href="https://en.wikipedia.org/wiki/Imaginary_number"><h3>Imaginary number</h3></a><p>An <b>imaginary number</b> is a real number multiplied by the imaginary unit <span class="texhtml mvar" style="font-style:italic">i</span>, which is defined by its property <span class="texhtml "><i>i</i><sup>2</sup> = \u22121</span>. The square of an imaginary number <span class="texhtml mvar" style="font-style:italic">bi</span> is <span class="texhtml ">\u2212<i>b</i><sup>2</sup></span>. For example, <span class="texhtml ">5<i>i</i></span> is an imaginary number, and its square is <span class="texhtml ">\u221225</span>. By definition, zero is considered to be both real and imaginary.</p>',ga='<a href="https://en.wikipedia.org/wiki/Real_number"><h3>Real number</h3></a><p>In mathematics, a <b>real number</b> is a value of a continuous quantity that can represent a distance along a line. The adjective <i>real</i> in this context was introduced in the 17th century by Ren\xE9 Descartes, who distinguished between real and imaginary roots of polynomials. The real numbers include all the rational numbers, such as the integer \u22125 and the fraction 4/3, and all the irrational numbers, such as <span class="mwe-math-element"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/b4afc1e27d418021bf10898eb44a7f5f315735ff" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align:-0.671ex;width:3.098ex;height:3.009ex" /></span>. Included within the irrationals are the real transcendental numbers, such as <span><span class="texhtml mvar" style="font-style:italic">\u03C0</span></span> (3.14159265...). In addition to measuring distance, real numbers can be used to measure quantities such as time, mass, energy, velocity, and many more. The set of real numbers is denoted using the symbol <b>R</b> or <span class="mwe-math-element"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/786849c765da7a84dbc3cce43e96aad58a5868dc" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align:-0.338ex;width:1.678ex;height:2.176ex" /></span> and is sometimes called "the reals".</p>',ba='<a href="https://en.wikipedia.org/wiki/Complex_plane"><h3>Complex plane</h3></a><p>In mathematics, the <b>complex plane</b> is the plane formed by the complex numbers, with a Cartesian coordinate system such that the <span class="texhtml mvar" style="font-style:italic">x</span>-axis, called <b>real axis</b>, is formed by the real numbers, and the <span class="texhtml mvar" style="font-style:italic">y</span>-axis, called <b>imaginary axis</b>, is formed by the imaginary numbers.</p>',va='<a href="https://en.wikipedia.org/wiki/Norm_(mathematics)"><h3>Norm (mathematics)</h3></a><p>In mathematics, a <b>norm</b> is a function from a real or complex vector space to the non-negative real numbers that behaves in certain ways like the distance from the origin: it commutes with scaling, obeys a form of the triangle inequality, and is zero only at the origin. In particular, the Euclidean distance of a vector from the origin is a norm, called the Euclidean norm, or 2-norm, which may also be defined as the square root of the inner product of a vector with itself.</p>';function ya(a){let e;return{c(){e=h("imaginary")},l(n){e=c(n,"imaginary")},m(n,u){B(n,e,u)},d(n){n&&s(e)}}}function wa(a){let e;return{c(){e=h("real")},l(n){e=c(n,"real")},m(n,u){B(n,e,u)},d(n){n&&s(e)}}}function $a(a){let e;return{c(){e=h("complex plane")},l(n){e=c(n,"complex plane")},m(n,u){B(n,e,u)},d(n){n&&s(e)}}}function qa(a){let e;return{c(){e=h("norm")},l(n){e=c(n,"norm")},m(n,u){B(n,e,u)},d(n){n&&s(e)}}}function Ta(a){let e,n,u,d=P("z \\in \\mathbb{C}")+"",p,$,q=P("z = a i + b,")+"",z,_,b=P("a, b \\in \\mathbb{R}")+"",S,l,T=P("i = \\sqrt{-1}.")+"",L,G,re=P("a")+"",K,ee,F,k,Ae=P("b")+"",Se,H,He,te,Ee=P("z.")+"",U,Y,be=P("a=0")+"",et,C,D,Ie,ie,de,X,Re=P("x")+"",ae,_e,Pe=P("y")+"",E,x,I,A,W,ze=P("\\Vert{z}\\Vert = \\sqrt{a^2 + b^2}")+"",Ne,ge,Ge,Z,j=P("z.")+"",Me,Ze,ue=P("\\Vert{z}\\Vert^2 = a^2 + b^2")+"",tt,Ye,V,ne,Le,at=P("z")+"",nt,Be,st=P("\\Vert{z}\\Vert \\cdot e^{i \\phi_z},")+"",ve,Ve,pt=P("\\phi_z \\in [0, 2\\pi].")+"",Xe,De,ft=P("e^{i \\phi_z}")+"",ye,Qe,We=P("\\phi_z")+"",we,Ce,dt=P("2\\pi")+"",je,oe,_t=P("z,")+"",Fe,Ue,wt=P("\\Vert{z}\\Vert")+"",Q,lt,ut,$t;return ee=new ot({props:{hovertext:_a,$$slots:{default:[ya]},$$scope:{ctx:a}}}),H=new ot({props:{hovertext:ga,$$slots:{default:[wa]},$$scope:{ctx:a}}}),ie=new ot({props:{hovertext:ba,$$slots:{default:[$a]},$$scope:{ctx:a}}}),ge=new ot({props:{hovertext:va,$$slots:{default:[qa]},$$scope:{ctx:a}}}),{c(){e=r("p"),n=h("The general form of a complex number "),u=r("span"),p=h(" is the following: "),$=r("span"),z=h(" where "),_=r("span"),S=h(" and "),l=r("span"),L=N(),G=r("span"),K=h(" is called the "),he(ee.$$.fragment),F=h(" and "),k=r("span"),Se=h(" the "),he(H.$$.fragment),He=h(" component of "),te=r("span"),U=h(" In fact, all real numbers are complex numbers, the imaginary component of which is zero ("),Y=r("span"),et=h(")."),C=N(),D=r("p"),Ie=h("Complex numbers can be represented geometrically as two-dimensional vectors in the so called "),he(ie.$$.fragment),de=h(", the "),X=r("span"),ae=h("-coordinate of which corresponds to the real, and the "),_e=r("span"),E=h("-coordinate to the imaginary component."),x=N(),I=r("p"),A=h("Let "),W=r("span"),Ne=h(" denote the Euclidean "),he(ge.$$.fragment),Ge=h(" of the vector associated with the complex number "),Z=r("span"),Me=h(" This concept is especially relevant in quantum computing, because the measurement probabilities of the basis states equals the square of the norm "),Ze=r("span"),tt=h(" of the complex coefficients defining the state of a qubit, as you can see above."),Ye=N(),V=r("p"),ne=h("Another important thing to note is that each 2-dimensional vector is uniquely defined by two properties: its length and angle of rotation. Consequently, a complex number "),Le=r("span"),nt=h(" can be expressed as "),Be=r("span"),ve=h(" where "),Ve=r("span"),Xe=h(" Here, "),De=r("span"),ye=h(" is a vector of unit length in the complex plane, rotated around the origin by an angle of "),Qe=r("span"),we=h(" ("),Ce=r("span"),je=h(" corresponds to a full rotation). All we have to do to get back "),oe=r("span"),Fe=h(" then, is multiply this rotated unit vector by "),Ue=r("span"),Q=h(" to adjust its norm.")},l(y){e=i(y,"P",{});var w=o(e);n=c(w,"The general form of a complex number "),u=i(w,"SPAN",{});var rt=o(u);rt.forEach(s),p=c(w," is the following: "),$=i(w,"SPAN",{});var m=o($);m.forEach(s),z=c(w," where "),_=i(w,"SPAN",{});var f=o(_);f.forEach(s),S=c(w," and "),l=i(w,"SPAN",{});var $e=o(l);$e.forEach(s),L=M(w),G=i(w,"SPAN",{});var Je=o(G);Je.forEach(s),K=c(w," is called the "),ce(ee.$$.fragment,w),F=c(w," and "),k=i(w,"SPAN",{});var qe=o(k);qe.forEach(s),Se=c(w," the "),ce(H.$$.fragment,w),He=c(w," component of "),te=i(w,"SPAN",{});var ke=o(te);ke.forEach(s),U=c(w," In fact, all real numbers are complex numbers, the imaginary component of which is zero ("),Y=i(w,"SPAN",{});var qt=o(Y);qt.forEach(s),et=c(w,")."),w.forEach(s),C=M(y),D=i(y,"P",{});var xe=o(D);Ie=c(xe,"Complex numbers can be represented geometrically as two-dimensional vectors in the so called "),ce(ie.$$.fragment,xe),de=c(xe,", the "),X=i(xe,"SPAN",{});var mt=o(X);mt.forEach(s),ae=c(xe,"-coordinate of which corresponds to the real, and the "),_e=i(xe,"SPAN",{});var me=o(_e);me.forEach(s),E=c(xe,"-coordinate to the imaginary component."),xe.forEach(s),x=M(y),I=i(y,"P",{});var Te=o(I);A=c(Te,"Let "),W=i(Te,"SPAN",{});var ht=o(W);ht.forEach(s),Ne=c(Te," denote the Euclidean "),ce(ge.$$.fragment,Te),Ge=c(Te," of the vector associated with the complex number "),Z=i(Te,"SPAN",{});var Tt=o(Z);Tt.forEach(s),Me=c(Te," This concept is especially relevant in quantum computing, because the measurement probabilities of the basis states equals the square of the norm "),Ze=i(Te,"SPAN",{});var Et=o(Ze);Et.forEach(s),tt=c(Te," of the complex coefficients defining the state of a qubit, as you can see above."),Te.forEach(s),Ye=M(y),V=i(y,"P",{});var O=o(V);ne=c(O,"Another important thing to note is that each 2-dimensional vector is uniquely defined by two properties: its length and angle of rotation. Consequently, a complex number "),Le=i(O,"SPAN",{});var Ke=o(Le);Ke.forEach(s),nt=c(O," can be expressed as "),Be=i(O,"SPAN",{});var le=o(Be);le.forEach(s),ve=c(O," where "),Ve=i(O,"SPAN",{});var Pt=o(Ve);Pt.forEach(s),Xe=c(O," Here, "),De=i(O,"SPAN",{});var kt=o(De);kt.forEach(s),ye=c(O," is a vector of unit length in the complex plane, rotated around the origin by an angle of "),Qe=i(O,"SPAN",{});var At=o(Qe);At.forEach(s),we=c(O," ("),Ce=i(O,"SPAN",{});var St=o(Ce);St.forEach(s),je=c(O," corresponds to a full rotation). All we have to do to get back "),oe=i(O,"SPAN",{});var Ht=o(oe);Ht.forEach(s),Fe=c(O," then, is multiply this rotated unit vector by "),Ue=i(O,"SPAN",{});var Wt=o(Ue);Wt.forEach(s),Q=c(O," to adjust its norm."),O.forEach(s)},m(y,w){B(y,e,w),t(e,n),t(e,u),u.innerHTML=d,t(e,p),t(e,$),$.innerHTML=q,t(e,z),t(e,_),_.innerHTML=b,t(e,S),t(e,l),l.innerHTML=T,t(e,L),t(e,G),G.innerHTML=re,t(e,K),pe(ee,e,null),t(e,F),t(e,k),k.innerHTML=Ae,t(e,Se),pe(H,e,null),t(e,He),t(e,te),te.innerHTML=Ee,t(e,U),t(e,Y),Y.innerHTML=be,t(e,et),B(y,C,w),B(y,D,w),t(D,Ie),pe(ie,D,null),t(D,de),t(D,X),X.innerHTML=Re,t(D,ae),t(D,_e),_e.innerHTML=Pe,t(D,E),B(y,x,w),B(y,I,w),t(I,A),t(I,W),W.innerHTML=ze,t(I,Ne),pe(ge,I,null),t(I,Ge),t(I,Z),Z.innerHTML=j,t(I,Me),t(I,Ze),Ze.innerHTML=ue,t(I,tt),B(y,Ye,w),B(y,V,w),t(V,ne),t(V,Le),Le.innerHTML=at,t(V,nt),t(V,Be),Be.innerHTML=st,t(V,ve),t(V,Ve),Ve.innerHTML=pt,t(V,Xe),t(V,De),De.innerHTML=ft,t(V,ye),t(V,Qe),Qe.innerHTML=We,t(V,we),t(V,Ce),Ce.innerHTML=dt,t(V,je),t(V,oe),oe.innerHTML=_t,t(V,Fe),t(V,Ue),Ue.innerHTML=wt,t(V,Q),lt=!0,ut||($t=[v(u,"mouseenter",a[0]),v($,"mouseenter",a[1]),v(_,"mouseenter",a[2]),v(l,"mouseenter",a[3]),v(G,"mouseenter",a[4]),v(k,"mouseenter",a[5]),v(te,"mouseenter",a[6]),v(Y,"mouseenter",a[7]),v(X,"mouseenter",a[8]),v(_e,"mouseenter",a[9]),v(W,"mouseenter",a[10]),v(Z,"mouseenter",a[11]),v(Ze,"mouseenter",a[12]),v(Le,"mouseenter",a[13]),v(Be,"mouseenter",a[14]),v(Ve,"mouseenter",a[15]),v(De,"mouseenter",a[16]),v(Qe,"mouseenter",a[17]),v(Ce,"mouseenter",a[18]),v(oe,"mouseenter",a[19]),v(Ue,"mouseenter",a[20])],ut=!0)},p(y,[w]){const rt={};w&2097152&&(rt.$$scope={dirty:w,ctx:y}),ee.$set(rt);const m={};w&2097152&&(m.$$scope={dirty:w,ctx:y}),H.$set(m);const f={};w&2097152&&(f.$$scope={dirty:w,ctx:y}),ie.$set(f);const $e={};w&2097152&&($e.$$scope={dirty:w,ctx:y}),ge.$set($e)},i(y){lt||(J(ee.$$.fragment,y),J(H.$$.fragment,y),J(ie.$$.fragment,y),J(ge.$$.fragment,y),lt=!0)},o(y){se(ee.$$.fragment,y),se(H.$$.fragment,y),se(ie.$$.fragment,y),se(ge.$$.fragment,y),lt=!1},d(y){y&&s(e),fe(ee),fe(H),y&&s(C),y&&s(D),fe(ie),y&&s(x),y&&s(I),fe(ge),y&&s(Ye),y&&s(V),ut=!1,Lt($t)}}}function R(a){console.log(a)}function Ea(a){return[()=>R(["z","C"]),()=>R(["a","b","z"]),()=>R(["a","b","R"]),()=>R([]),()=>R(["a"]),()=>R(["b"]),()=>R(["z"]),()=>R(["a"]),()=>R(["x"]),()=>R(["y"]),()=>R(["a","b","z"]),()=>R(["z"]),()=>R(["a","b","z"]),()=>R(["z"]),()=>R(["\\phi","z"]),()=>R(["\\phi","z"]),()=>R(["\\phi","z"]),()=>R(["\\phi","z"]),()=>R([]),()=>R(["z"]),()=>R(["z"])]}class Pa extends Mt{constructor(e){super(),xt(this,e,Ea,Ta,zt,{})}}function Yt(a,e,n){const u=a.slice();return u[10]=e[n],u}function Xt(a){let e,n=a[10].name+"",u,d;return{c(){e=r("option"),u=h(n),d=N(),this.h()},l(p){e=i(p,"OPTION",{});var $=o(e);u=c($,n),d=M($),$.forEach(s),this.h()},h(){e.__value=a[10],e.value=e.__value},m(p,$){B(p,e,$),t(e,u),t(e,d)},p:Ct,d(p){p&&s(e)}}}function ka(a){let e,n,u,d,p=P(a[1])+"",$,q,z=a[2],_=[];for(let b=0;b<z.length;b+=1)_[b]=Xt(Yt(a,z,b));return{c(){e=r("div"),n=r("select");for(let b=0;b<_.length;b+=1)_[b].c();u=N(),d=r("div"),this.h()},l(b){e=i(b,"DIV",{class:!0});var S=o(e);n=i(S,"SELECT",{});var l=o(n);for(let L=0;L<_.length;L+=1)_[L].l(l);l.forEach(s),S.forEach(s),u=M(b),d=i(b,"DIV",{class:!0});var T=o(d);T.forEach(s),this.h()},h(){a[0]===void 0&&Zt(()=>a[7].call(n)),g(e,"class","pt-4"),g(d,"class","pt-4")},m(b,S){B(b,e,S),t(e,n);for(let l=0;l<_.length;l+=1)_[l].m(n,null);jt(n,a[0]),B(b,u,S),B(b,d,S),d.innerHTML=p,$||(q=[v(n,"change",a[7]),v(n,"change",a[3])],$=!0)},p(b,[S]){if(S&4){z=b[2];let l;for(l=0;l<z.length;l+=1){const T=Yt(b,z,l);_[l]?_[l].p(T,S):(_[l]=Xt(T),_[l].c(),_[l].m(n,null))}for(;l<_.length;l+=1)_[l].d(1);_.length=z.length}S&5&&jt(n,b[0]),S&2&&p!==(p=P(b[1])+"")&&(d.innerHTML=p)},i:Ct,o:Ct,d(b){b&&s(e),Jt(_,b),b&&s(u),b&&s(d),$=!1,Lt(q)}}}function Aa(a,e,n){let u=[{name:"Identity Gate",matrix:ct([[1,0],[0,1]]),display:"{\\displaystyle I={\\begin{bmatrix}1&0\\\\0&1\\end{bmatrix}}}"},{name:"Hadamard Gate",matrix:yt.H,display:"{\\displaystyle H={\\frac {1}{\\sqrt {2}}}{\\begin{bmatrix}1&1 \\\\ 1&-1\\end{bmatrix}}}"},{name:"Pauli-X",matrix:ct(yt.X),display:"{\\displaystyle X=\\sigma _{x}=\\operatorname {NOT} ={\\begin{bmatrix}0&1\\\\1&0\\end{bmatrix}}}"},{name:"Pauli-Y",matrix:ct(yt.Y),display:"{\\displaystyle Y=\\sigma _{y}={\\begin{bmatrix}0&-i\\\\i&0\\end{bmatrix}}}"},{name:"Pauli-Z",matrix:ct(yt.Z),display:"{\\displaystyle Z=\\sigma _{z}={\\begin{bmatrix}1&0\\\\0&-1\\end{bmatrix}}}"},{name:"\u221ANOT",matrix:yt.sqrtX,display:"{\\displaystyle {\\sqrt {X}}={\\sqrt {\\text{NOT}}}={\\frac{1}{2}}{\\begin{bmatrix}1+i&1-i\\\\1-i&1+i \\end{bmatrix}}}"}],{gate:d=u[0]}=e,{transitionTime:p=800}=e,{transitionSteps:$=20}=e,{currentMatrix:q=u[0].matrix}=e,z,_="";function b(){z=sa(ra(d.matrix,q),$),S(0),n(1,_=d.display)}function S(T){setTimeout(()=>{n(4,q=ia(q,z)),T>=$-1?n(4,q=d.matrix):S(T+1)},p/$)}function l(){d=Kt(this),n(0,d),n(2,u)}return a.$$set=T=>{"gate"in T&&n(0,d=T.gate),"transitionTime"in T&&n(5,p=T.transitionTime),"transitionSteps"in T&&n(6,$=T.transitionSteps),"currentMatrix"in T&&n(4,q=T.currentMatrix)},[d,_,u,b,q,p,$,l]}class Sa extends Mt{constructor(e){super(),xt(this,e,Aa,ka,zt,{gate:0,transitionTime:5,transitionSteps:6,currentMatrix:4})}}function Ft(a){let e,n,u,d;return n=new Pa({}),{c(){e=r("div"),he(n.$$.fragment)},l(p){e=i(p,"DIV",{});var $=o(e);ce(n.$$.fragment,$),$.forEach(s)},m(p,$){B(p,e,$),pe(n,e,null),d=!0},i(p){d||(J(n.$$.fragment,p),Zt(()=>{u||(u=Rt(e,Gt,{duration:400},!0)),u.run(1)}),d=!0)},o(p){se(n.$$.fragment,p),u||(u=Rt(e,Gt,{duration:400},!1)),u.run(0),d=!1},d(p){p&&s(e),fe(n),p&&u&&u.end()}}}function Ha(a){let e,n,u,d,p,$,q,z,_,b,S,l,T,L,G,re,K,ee,F,k,Ae,Se=P("\\phi_\\alpha")+"",H,He,te,Ee=P("\\phi_\\beta")+"",U,Y,be,et=P("r_\\alpha")+"",C,D,Ie,ie,de,X,Re,ae,_e,Pe,E,x,I,A,W,ze,Ne,ge,Ge,Z,j,Me,Ze=P("\\theta")+"",ue,tt,Ye,V=P("\\phi")+"",ne,Le,at,nt,Be,st,ve,Ve,pt,Xe,De,ft,ye,Qe,We,we,Ce,dt,je,oe,_t,Fe,Ue,wt;p=new aa({});let Q=a[9]&&Ft();ae=new Qt({props:{displayBloch:a[6],phiAlpha:a[13],phiBeta:a[12],rAlpha:a[5],blochClass:"col-lg-4 col-md-12",vectorClass:"col-lg-4 col-md-12"}}),Pe=new na({}),x=new da({});function lt(m){a[21](m)}let ut={};a[8]!==void 0&&(ut.currentMatrix=a[8]),ve=new Sa({props:ut}),Bt.push(()=>Vt(ve,"currentMatrix",lt));function $t(m){a[23](m)}let y={displayBloch:a[7],displayVectors:!a[7],phiBeta:-a[10],rAlpha:It(a[11]/2)};a[4]!==void 0&&(y.cameraPosition=a[4]),we=new Qt({props:y}),Bt.push(()=>Vt(we,"cameraPosition",$t));function w(m){a[24](m)}let rt={displayBloch:a[7],displayVectors:!a[7],phiBeta:-a[10],rAlpha:It(a[11]/2),quantumGates:[a[8]]};return a[4]!==void 0&&(rt.cameraPosition=a[4]),oe=new Qt({props:rt}),Bt.push(()=>Vt(oe,"cameraPosition",w)),{c(){e=r("init"),n=r("h1"),u=h("Quantum Tinkering"),d=N(),he(p.$$.fragment),$=N(),q=r("h2"),z=h("Important properties of complex numbers "),_=r("span"),S=N(),Q&&Q.c(),l=N(),T=r("div"),L=r("div"),G=r("div"),re=r("p"),K=h(`Play around with 2 representations of a single qubit. You adjust the view of the 3D Bloch
					sphere by clicking on the image and dragging.`),ee=N(),F=r("div"),k=r("div"),Ae=new gt(!1),H=r("input"),He=N(),te=new gt(!1),U=r("input"),Y=N(),be=new gt(!1),C=r("input"),D=N(),Ie=r("b"),ie=h("Display Bloch sphere"),de=N(),X=r("input"),Re=N(),he(ae.$$.fragment),_e=N(),he(Pe.$$.fragment),E=N(),he(x.$$.fragment),I=N(),A=r("div"),W=r("div"),ze=r("div"),Ne=r("p"),ge=h("Look at the how a quantum gate - expressed as a unitary matrix - transforms a Bloch sphere"),Ge=N(),Z=r("div"),j=r("div"),Me=new gt(!1),ue=r("input"),tt=N(),Ye=new gt(!1),ne=r("input"),Le=N(),at=r("span"),nt=h("Select quantum gate"),Be=N(),st=r("div"),he(ve.$$.fragment),pt=N(),Xe=r("b"),De=h("Toggle Bloch/vectors"),ft=N(),ye=r("input"),Qe=N(),We=r("div"),he(we.$$.fragment),dt=N(),je=r("div"),he(oe.$$.fragment),this.h()},l(m){e=i(m,"INIT",{class:!0});var f=o(e);n=i(f,"H1",{});var $e=o(n);u=c($e,"Quantum Tinkering"),$e.forEach(s),d=M(f),ce(p.$$.fragment,f),$=M(f),q=i(f,"H2",{type:!0});var Je=o(q);z=c(Je,"Important properties of complex numbers "),_=i(Je,"SPAN",{class:!0}),o(_).forEach(s),Je.forEach(s),S=M(f),Q&&Q.l(f),l=M(f),T=i(f,"DIV",{class:!0});var qe=o(T);L=i(qe,"DIV",{class:!0});var ke=o(L);G=i(ke,"DIV",{class:!0});var qt=o(G);re=i(qt,"P",{});var xe=o(re);K=c(xe,`Play around with 2 representations of a single qubit. You adjust the view of the 3D Bloch
					sphere by clicking on the image and dragging.`),xe.forEach(s),qt.forEach(s),ke.forEach(s),ee=M(qe),F=i(qe,"DIV",{class:!0});var mt=o(F);k=i(mt,"DIV",{class:!0});var me=o(k);Ae=bt(me,!1),H=i(me,"INPUT",{type:!0,min:!0,max:!0,step:!0,class:!0}),He=M(me),te=bt(me,!1),U=i(me,"INPUT",{type:!0,min:!0,max:!0,step:!0,class:!0}),Y=M(me),be=bt(me,!1),C=i(me,"INPUT",{type:!0,min:!0,max:!0,step:!0,class:!0}),D=M(me),Ie=i(me,"B",{});var Te=o(Ie);ie=c(Te,"Display Bloch sphere"),Te.forEach(s),de=M(me),X=i(me,"INPUT",{type:!0,style:!0,class:!0}),me.forEach(s),Re=M(mt),ce(ae.$$.fragment,mt),mt.forEach(s),qe.forEach(s),_e=M(f),ce(Pe.$$.fragment,f),E=M(f),ce(x.$$.fragment,f),I=M(f),A=i(f,"DIV",{class:!0});var ht=o(A);W=i(ht,"DIV",{class:!0});var Tt=o(W);ze=i(Tt,"DIV",{class:!0});var Et=o(ze);Ne=i(Et,"P",{});var O=o(Ne);ge=c(O,"Look at the how a quantum gate - expressed as a unitary matrix - transforms a Bloch sphere"),O.forEach(s),Et.forEach(s),Tt.forEach(s),Ge=M(ht),Z=i(ht,"DIV",{class:!0});var Ke=o(Z);j=i(Ke,"DIV",{class:!0});var le=o(j);Me=bt(le,!1),ue=i(le,"INPUT",{type:!0,min:!0,max:!0,step:!0,class:!0}),tt=M(le),Ye=bt(le,!1),ne=i(le,"INPUT",{type:!0,min:!0,max:!0,step:!0,class:!0}),Le=M(le),at=i(le,"SPAN",{});var Pt=o(at);nt=c(Pt,"Select quantum gate"),Pt.forEach(s),Be=M(le),st=i(le,"DIV",{});var kt=o(st);ce(ve.$$.fragment,kt),kt.forEach(s),pt=M(le),Xe=i(le,"B",{});var At=o(Xe);De=c(At,"Toggle Bloch/vectors"),At.forEach(s),ft=M(le),ye=i(le,"INPUT",{type:!0,style:!0,class:!0}),le.forEach(s),Qe=M(Ke),We=i(Ke,"DIV",{class:!0});var St=o(We);ce(we.$$.fragment,St),St.forEach(s),dt=M(Ke),je=i(Ke,"DIV",{class:!0});var Ht=o(je);ce(oe.$$.fragment,Ht),Ht.forEach(s),Ke.forEach(s),ht.forEach(s),f.forEach(s),this.h()},h(){g(_,"class",b=Ut(`arrow ${a[9]?"down":""}`)+" svelte-11ijcq0"),g(q,"type","button"),g(G,"class","col-12"),g(L,"class","row mb-4"),Ae.a=H,g(H,"type","range"),g(H,"min",0),g(H,"max",360),g(H,"step",1),g(H,"class","svelte-11ijcq0"),te.a=U,g(U,"type","range"),g(U,"min",0),g(U,"max",360),g(U,"step",1),g(U,"class","svelte-11ijcq0"),be.a=C,g(C,"type","range"),g(C,"min",0),g(C,"max",1),g(C,"step",.01),g(C,"class","svelte-11ijcq0"),g(X,"type","checkbox"),Ot(X,"width","auto"),g(X,"class","svelte-11ijcq0"),g(k,"class","col-lg-4 col-md-12"),g(F,"class","row"),g(T,"class","interaction container mt-3"),g(ze,"class","col-12"),g(W,"class","row mb-4"),Me.a=ue,g(ue,"type","range"),g(ue,"min",0),g(ue,"max",180),g(ue,"step",1),g(ue,"class","svelte-11ijcq0"),Ye.a=ne,g(ne,"type","range"),g(ne,"min",0),g(ne,"max",360),g(ne,"step",1),g(ne,"class","svelte-11ijcq0"),g(ye,"type","checkbox"),Ot(ye,"width","auto"),g(ye,"class","svelte-11ijcq0"),g(j,"class","col-lg-4 col-md-12"),g(We,"class","col-lg-4 col-md-12"),g(je,"class","col-lg-4 col-md-12"),g(Z,"class","row"),g(A,"class","interaction container"),g(e,"class","svelte-11ijcq0")},m(m,f){B(m,e,f),t(e,n),t(n,u),t(e,d),pe(p,e,null),t(e,$),t(e,q),t(q,z),t(q,_),t(e,S),Q&&Q.m(e,null),t(e,l),t(e,T),t(T,L),t(L,G),t(G,re),t(re,K),t(T,ee),t(T,F),t(F,k),Ae.m(Se,k),t(k,H),Oe(H,a[0]),t(k,He),te.m(Ee,k),t(k,U),Oe(U,a[1]),t(k,Y),be.m(et,k),t(k,C),Oe(C,a[5]),t(k,D),t(k,Ie),t(Ie,ie),t(k,de),t(k,X),X.checked=a[6],t(F,Re),pe(ae,F,null),t(e,_e),pe(Pe,e,null),t(e,E),pe(x,e,null),t(e,I),t(e,A),t(A,W),t(W,ze),t(ze,Ne),t(Ne,ge),t(A,Ge),t(A,Z),t(Z,j),Me.m(Ze,j),t(j,ue),Oe(ue,a[2]),t(j,tt),Ye.m(V,j),t(j,ne),Oe(ne,a[3]),t(j,Le),t(j,at),t(at,nt),t(j,Be),t(j,st),pe(ve,st,null),t(j,pt),t(j,Xe),t(Xe,De),t(j,ft),t(j,ye),ye.checked=a[7],t(Z,Qe),t(Z,We),pe(we,We,null),t(Z,dt),t(Z,je),pe(oe,je,null),Fe=!0,Ue||(wt=[v(q,"click",a[14]),v(H,"change",a[15]),v(H,"input",a[15]),v(U,"change",a[16]),v(U,"input",a[16]),v(C,"change",a[17]),v(C,"input",a[17]),v(X,"change",a[18]),v(ue,"change",a[19]),v(ue,"input",a[19]),v(ne,"change",a[20]),v(ne,"input",a[20]),v(ye,"change",a[22])],Ue=!0)},p(m,[f]){(!Fe||f&512&&b!==(b=Ut(`arrow ${m[9]?"down":""}`)+" svelte-11ijcq0"))&&g(_,"class",b),m[9]?Q?f&512&&J(Q,1):(Q=Ft(),Q.c(),J(Q,1),Q.m(e,l)):Q&&(ta(),se(Q,1,1,()=>{Q=null}),ea()),f&1&&Oe(H,m[0]),f&2&&Oe(U,m[1]),f&32&&Oe(C,m[5]),f&64&&(X.checked=m[6]);const $e={};f&64&&($e.displayBloch=m[6]),f&8192&&($e.phiAlpha=m[13]),f&4096&&($e.phiBeta=m[12]),f&32&&($e.rAlpha=m[5]),ae.$set($e),f&4&&Oe(ue,m[2]),f&8&&Oe(ne,m[3]);const Je={};!Ve&&f&256&&(Ve=!0,Je.currentMatrix=m[8],Dt(()=>Ve=!1)),ve.$set(Je),f&128&&(ye.checked=m[7]);const qe={};f&128&&(qe.displayBloch=m[7]),f&128&&(qe.displayVectors=!m[7]),f&1024&&(qe.phiBeta=-m[10]),f&2048&&(qe.rAlpha=It(m[11]/2)),!Ce&&f&16&&(Ce=!0,qe.cameraPosition=m[4],Dt(()=>Ce=!1)),we.$set(qe);const ke={};f&128&&(ke.displayBloch=m[7]),f&128&&(ke.displayVectors=!m[7]),f&1024&&(ke.phiBeta=-m[10]),f&2048&&(ke.rAlpha=It(m[11]/2)),f&256&&(ke.quantumGates=[m[8]]),!_t&&f&16&&(_t=!0,ke.cameraPosition=m[4],Dt(()=>_t=!1)),oe.$set(ke)},i(m){Fe||(J(p.$$.fragment,m),J(Q),J(ae.$$.fragment,m),J(Pe.$$.fragment,m),J(x.$$.fragment,m),J(ve.$$.fragment,m),J(we.$$.fragment,m),J(oe.$$.fragment,m),Fe=!0)},o(m){se(p.$$.fragment,m),se(Q),se(ae.$$.fragment,m),se(Pe.$$.fragment,m),se(x.$$.fragment,m),se(ve.$$.fragment,m),se(we.$$.fragment,m),se(oe.$$.fragment,m),Fe=!1},d(m){m&&s(e),fe(p),Q&&Q.d(),fe(ae),fe(Pe),fe(x),fe(ve),fe(we),fe(oe),Ue=!1,Lt(wt)}}}function Ia(a,e,n){let u,d,p,$,q={x:4,y:.3,z:.5},z=15,_=310,b=.9,S=!1,l=!0,T=30,L=50;ct([[1,0],[0,1]]);let G=ct([[1,0],[0,1]]),re=!1;const K=()=>n(9,re=!re);function ee(){z=vt(this.value),n(0,z)}function F(){_=vt(this.value),n(1,_)}function k(){b=vt(this.value),n(5,b)}function Ae(){S=this.checked,n(6,S)}function Se(){T=vt(this.value),n(2,T)}function H(){L=vt(this.value),n(3,L)}function He(Y){G=Y,n(8,G)}function te(){l=this.checked,n(7,l)}function Ee(Y){q=Y,n(4,q)}function U(Y){q=Y,n(4,q)}return a.$$.update=()=>{a.$$.dirty&1&&n(13,u=z/180*Nt),a.$$.dirty&2&&n(12,d=_/180*Nt),a.$$.dirty&4&&n(11,p=T/180*Nt),a.$$.dirty&8&&n(10,$=L/180*Nt)},[z,_,T,L,q,b,S,l,G,re,$,p,d,u,K,ee,F,k,Ae,Se,H,He,te,Ee,U]}class Ba extends Mt{constructor(e){super(),xt(this,e,Ia,Ha,zt,{})}}export{Ba as default};
