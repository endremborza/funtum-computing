import{S as va,i as ba,s as ga,l as i,u as h,a as S,U as Qe,e as Zs,m as l,p as u,v as f,h as a,c as A,V as Re,q as F,b as y,H as n,X as Ct,L as d,a4 as Nu,_ as vr,a2 as $u,n as Js,M as es,x as Le,y as qe,z as xe,f as Pe,t as Se,C as Ie,$ as Yr,a0 as Jr,g as Eu,d as ku,P as kl,w as wl,N as Tu,Z as Tl,r as Mu}from"../chunks/index-ca49edcf.js";import{m as p,K as go,q as zo,G as Ml,H as Pu,k as Su,p as ol,F as Au}from"../chunks/index-ba7e8b36.js";import{H as Rt,d as Pl,Q as Hu,a as Lu}from"../chunks/QuantumQubit-ab753e9a.js";import{Q as qu}from"../chunks/Qubit-bb2ae073.js";function xu(e){let t,r,s,o=p(`K = ${e[6]}`)+"",c,_,m=p("r")+"",b,v,k=p("a^r \\mod N = 1")+"",w,E,N,Q,K,V=p("r")+"",L,z,x=p(`${e[1]}^{${e[2]}} \\mod ${e[0]} = 1`)+"",H,I,j=p("m")+"",Y,P,re=p(`${e[1]}^{${e[2]}} = m \\cdot ${e[0]} + 1`)+"",X,D;function M(B,R){return B[2]%2==0?Qu:Fu}let q=M(e),ee=q(e);return{c(){t=i("p"),r=h("As "),s=new Qe(!1),c=h(", the value of "),_=new Qe(!1),b=h(" in "),v=new Qe(!1),w=h(` will
		be informative.`),E=S(),N=i("p"),Q=h(`As these are all relatively small numbers, we can try all relevant possible values for
		`),K=new Qe(!1),L=h(" rather quickly and find that "),z=new Qe(!1),H=h(` which means
		that there is an `),I=new Qe(!1),Y=h(" for which "),P=new Qe(!1),X=S(),D=i("p"),ee.c(),this.h()},l(B){t=l(B,"P",{});var R=u(t);r=f(R,"As "),s=Re(R,!1),c=f(R,", the value of "),_=Re(R,!1),b=f(R," in "),v=Re(R,!1),w=f(R,` will
		be informative.`),R.forEach(a),E=A(B),N=l(B,"P",{});var U=u(N);Q=f(U,`As these are all relatively small numbers, we can try all relevant possible values for
		`),K=Re(U,!1),L=f(U," rather quickly and find that "),z=Re(U,!1),H=f(U,` which means
		that there is an `),I=Re(U,!1),Y=f(U," for which "),P=Re(U,!1),U.forEach(a),X=A(B),D=l(B,"P",{});var ie=u(D);ee.l(ie),ie.forEach(a),this.h()},h(){s.a=c,_.a=b,v.a=w,K.a=L,z.a=H,I.a=Y,P.a=null},m(B,R){y(B,t,R),n(t,r),s.m(o,t),n(t,c),_.m(m,t),n(t,b),v.m(k,t),n(t,w),y(B,E,R),y(B,N,R),n(N,Q),K.m(V,N),n(N,L),z.m(x,N),n(N,H),I.m(j,N),n(N,Y),P.m(re,N),y(B,X,R),y(B,D,R),ee.m(D,null)},p(B,R){R&64&&o!==(o=p(`K = ${B[6]}`)+"")&&s.p(o),R&7&&x!==(x=p(`${B[1]}^{${B[2]}} \\mod ${B[0]} = 1`)+"")&&z.p(x),R&7&&re!==(re=p(`${B[1]}^{${B[2]}} = m \\cdot ${B[0]} + 1`)+"")&&P.p(re),q===(q=M(B))&&ee?ee.p(B,R):(ee.d(1),ee=q(B),ee&&(ee.c(),ee.m(D,null)))},d(B){B&&a(t),B&&a(E),B&&a(N),B&&a(X),B&&a(D),ee.d()}}}function Iu(e){let t,r,s,o=p("K \\neq 1")+"",c,_,m=p("a")+"",b,v,k=p("N")+"",w,E,N=p(`K=${e[6]}`)+"",Q,K,V=p("a")+"",L;return{c(){t=i("p"),r=h("As in this case "),s=new Qe(!1),c=h(", a new "),_=new Qe(!1),b=h(` is needed. Or to put a more positive
		spin on it, we instantly can found a prime factor for `),v=new Qe(!1),w=h(`, which in fact
		`),E=new Qe(!1),Q=h(` is. However, in order to see the whole algorithm in action, we should choose
		a new `),K=new Qe(!1),L=h("."),this.h()},l(z){t=l(z,"P",{});var x=u(t);r=f(x,"As in this case "),s=Re(x,!1),c=f(x,", a new "),_=Re(x,!1),b=f(x,` is needed. Or to put a more positive
		spin on it, we instantly can found a prime factor for `),v=Re(x,!1),w=f(x,`, which in fact
		`),E=Re(x,!1),Q=f(x,` is. However, in order to see the whole algorithm in action, we should choose
		a new `),K=Re(x,!1),L=f(x,"."),x.forEach(a),this.h()},h(){s.a=c,_.a=b,v.a=w,E.a=Q,K.a=L},m(z,x){y(z,t,x),n(t,r),s.m(o,t),n(t,c),_.m(m,t),n(t,b),v.m(k,t),n(t,w),E.m(N,t),n(t,Q),K.m(V,t),n(t,L)},p(z,x){x&64&&N!==(N=p(`K=${z[6]}`)+"")&&E.p(N)},d(z){z&&a(t)}}}function Fu(e){let t,r=p("r")+"",s,o,c=p("a")+"",_;return{c(){t=new Qe(!1),s=h(" is odd, we need a new "),o=new Qe(!1),_=h("."),this.h()},l(m){t=Re(m,!1),s=f(m," is odd, we need a new "),o=Re(m,!1),_=f(m,"."),this.h()},h(){t.a=s,o.a=_},m(m,b){t.m(r,m,b),y(m,s,b),o.m(c,m,b),y(m,_,b)},p:Js,d(m){m&&t.d(),m&&a(s),m&&o.d(),m&&a(_)}}}function Qu(e){let t,r=p("r")+"",s,o,c=p("b = a^{\\frac{r}{2}}")+"",_,m,b=p("a^r = m \\cdot N + 1 \\Rightarrow b^2-1 = (b + 1)(b - 1) = m \\cdot N")+"",v,k,w=p(`b = ${e[5]}`)+"",E,N,Q=p("N")+"",K,V,L=p("b-1")+"",z,x,H=p("b+1")+"",I,j,Y=p(`${go(e[0],e[5]-1)}`)+"",P,re,X=p(`${go(e[0],e[5]+1)}`)+"",D;return{c(){t=new Qe(!1),s=h(" is even, so we can create "),o=new Qe(!1),_=h(`, and expand
			the above so that
			`),m=new Qe(!1),v=h(`. In this
			case, as `),k=new Qe(!1),E=h(`, we can calculate the greatest common divisor for
			`),N=new Qe(!1),K=h(" with "),V=new Qe(!1),z=h(" and "),x=new Qe(!1),I=h(` very quickly, which are
			`),j=new Qe(!1),P=h(" and "),re=new Qe(!1),D=h(" respectively"),this.h()},l(M){t=Re(M,!1),s=f(M," is even, so we can create "),o=Re(M,!1),_=f(M,`, and expand
			the above so that
			`),m=Re(M,!1),v=f(M,`. In this
			case, as `),k=Re(M,!1),E=f(M,`, we can calculate the greatest common divisor for
			`),N=Re(M,!1),K=f(M," with "),V=Re(M,!1),z=f(M," and "),x=Re(M,!1),I=f(M,` very quickly, which are
			`),j=Re(M,!1),P=f(M," and "),re=Re(M,!1),D=f(M," respectively"),this.h()},h(){t.a=s,o.a=_,m.a=v,k.a=E,N.a=K,V.a=z,x.a=I,j.a=P,re.a=D},m(M,q){t.m(r,M,q),y(M,s,q),o.m(c,M,q),y(M,_,q),m.m(b,M,q),y(M,v,q),k.m(w,M,q),y(M,E,q),N.m(Q,M,q),y(M,K,q),V.m(L,M,q),y(M,z,q),x.m(H,M,q),y(M,I,q),j.m(Y,M,q),y(M,P,q),re.m(X,M,q),y(M,D,q)},p(M,q){q&32&&w!==(w=p(`b = ${M[5]}`)+"")&&k.p(w),q&33&&Y!==(Y=p(`${go(M[0],M[5]-1)}`)+"")&&j.p(Y),q&33&&X!==(X=p(`${go(M[0],M[5]+1)}`)+"")&&re.p(X)},d(M){M&&t.d(),M&&a(s),M&&o.d(),M&&a(_),M&&m.d(),M&&a(v),M&&k.d(),M&&a(E),M&&N.d(),M&&a(K),M&&V.d(),M&&a(z),M&&x.d(),M&&a(I),M&&j.d(),M&&a(P),M&&re.d(),M&&a(D)}}}function Ru(e){let t,r,s,o,c,_,m,b,v,k,w,E,N,Q,K,V,L,z=p(` = ${e[3]} \\cdot ${e[4]}`)+"",x,H,I,j,Y=p(`a = ${e[1]}`)+"",P,re,X=p(`N = ${e[0]}`)+"",D,M,q=p(`K = ${e[6]}`)+"",ee,B,R,U,ie;function te(Z,T){return Z[6]!=1?Iu:xu}let Ee=te(e),he=Ee(e);return{c(){t=i("div"),r=i("div"),s=h("a:"),o=S(),c=i("input"),m=S(),b=i("input"),k=S(),w=i("div"),E=h("N:"),N=S(),Q=i("input"),V=S(),L=i("div"),x=S(),H=i("p"),I=h("The greatest common divisor of "),j=new Qe(!1),P=h(" and "),re=new Qe(!1),D=h(` is
	`),M=new Qe(!1),ee=h(". This is very quick to calculate."),B=S(),he.c(),R=Zs(),this.h()},l(Z){t=l(Z,"DIV",{class:!0});var T=u(t);r=l(T,"DIV",{class:!0});var J=u(r);s=f(J,"a:"),J.forEach(a),o=A(T),c=l(T,"INPUT",{class:!0,type:!0,min:!0,max:!0}),m=A(T),b=l(T,"INPUT",{class:!0,type:!0,min:!0,max:!0}),k=A(T),w=l(T,"DIV",{class:!0});var de=u(w);E=f(de,"N:"),de.forEach(a),N=A(T),Q=l(T,"INPUT",{class:!0,type:!0,min:!0,max:!0}),V=A(T),L=l(T,"DIV",{id:!0,class:!0});var We=u(L);We.forEach(a),T.forEach(a),x=A(Z),H=l(Z,"P",{});var be=u(H);I=f(be,"The greatest common divisor of "),j=Re(be,!1),P=f(be," and "),re=Re(be,!1),D=f(be,` is
	`),M=Re(be,!1),ee=f(be,". This is very quick to calculate."),be.forEach(a),B=A(Z),he.l(Z),R=Zs(),this.h()},h(){F(r,"class","varlabel svelte-1lqus27"),F(c,"class","numsel svelte-1lqus27"),F(c,"type","number"),F(c,"min",2),F(c,"max",_=e[0]-1),F(b,"class","slider svelte-1lqus27"),F(b,"type","range"),F(b,"min",2),F(b,"max",v=e[0]-1),F(w,"class","varlabel svelte-1lqus27"),F(Q,"class","numsel svelte-1lqus27"),F(Q,"type","number"),F(Q,"min","1"),F(Q,"max",e[7]),F(L,"id","decomp"),F(L,"class","svelte-1lqus27"),F(t,"class","cpanel svelte-1lqus27"),j.a=P,re.a=D,M.a=ee},m(Z,T){y(Z,t,T),n(t,r),n(r,s),n(t,o),n(t,c),Ct(c,e[1]),n(t,m),n(t,b),Ct(b,e[1]),n(t,k),n(t,w),n(w,E),n(t,N),n(t,Q),Ct(Q,e[0]),n(t,V),n(t,L),L.innerHTML=z,y(Z,x,T),y(Z,H,T),n(H,I),j.m(Y,H),n(H,P),re.m(X,H),n(H,D),M.m(q,H),n(H,ee),y(Z,B,T),he.m(Z,T),y(Z,R,T),U||(ie=[d(c,"input",e[10]),d(b,"change",e[11]),d(b,"input",e[11]),Nu(K=e[8].call(null,Q,e[0])),d(Q,"input",e[12])],U=!0)},p(Z,[T]){T&1&&_!==(_=Z[0]-1)&&F(c,"max",_),T&2&&vr(c.value)!==Z[1]&&Ct(c,Z[1]),T&1&&v!==(v=Z[0]-1)&&F(b,"max",v),T&2&&Ct(b,Z[1]),K&&$u(K.update)&&T&1&&K.update.call(null,Z[0]),T&1&&vr(Q.value)!==Z[0]&&Ct(Q,Z[0]),T&24&&z!==(z=p(` = ${Z[3]} \\cdot ${Z[4]}`)+"")&&(L.innerHTML=z),T&2&&Y!==(Y=p(`a = ${Z[1]}`)+"")&&j.p(Y),T&1&&X!==(X=p(`N = ${Z[0]}`)+"")&&re.p(X),T&64&&q!==(q=p(`K = ${Z[6]}`)+"")&&M.p(q),Ee===(Ee=te(Z))&&he?he.p(Z,T):(he.d(1),he=Ee(Z),he&&(he.c(),he.m(R.parentNode,R)))},i:Js,o:Js,d(Z){Z&&a(t),Z&&a(x),Z&&a(H),Z&&a(B),he.d(Z),Z&&a(R),U=!1,es(ie)}}}function Cu(e,t){for(let r=1;r<t;r++){let s=e%t;for(let o=1;o<r;o++)s=s*e%t;if(s==1)return r}return 0}function Bu(e,t,r){let s,o,c,{bits:_=7}=t,m=Math.pow(2,_)-1;const b=new Set;for(let H=2;H<=m/2;H++){let I=!0;b.forEach(function(j){H%j==0&&(I=!1)}),I&&b.add(H)}let v=39,k=v,w=7,E,N;function Q(H){for(const I of b)if(b.has(H/I))return r(3,E=I),r(4,N=H/I),!0;return!1}Q(v);function K(H,I){return{update(j){let Y=j-k;if(Y!=0){for(;!Q(j);)if(j+=Y,j<=2||j>=m)return;V(j)}}}}function V(H){r(0,v=H),k=v,r(1,w=w>=v?v-1:w)}function L(){w=vr(this.value),r(1,w)}function z(){w=vr(this.value),r(1,w)}function x(){v=vr(this.value),r(0,v)}return e.$$set=H=>{"bits"in H&&r(9,_=H.bits)},e.$$.update=()=>{e.$$.dirty&3&&r(2,s=Cu(w,v)),e.$$.dirty&3&&r(6,o=go(v,w)),e.$$.dirty&6&&r(5,c=Math.pow(w,s/2))},[v,w,s,E,N,c,o,m,K,_,L,z,x]}class Du extends va{constructor(t){super(),ba(this,t,Bu,Ru,ga,{bits:9})}}const Wu=`<a href="https://en.wikipedia.org/wiki/Semiprime"><h3 class="text-lg font-semibold">Semiprime</h3></a><p>In mathematics, a <b>semiprime</b> is a natural number that is the product of exactly two prime numbers. The two primes in the product may equal each other, so the semiprimes include the squares of prime numbers.
Because there are infinitely many prime numbers, there are also infinitely many semiprimes. Semiprimes are also called <b>biprimes</b>.</p>`,zu='<a href="https://en.wikipedia.org/wiki/General_number_field_sieve"><h3>General number field sieve</h3></a><p>In number theory, the <b>general number field sieve</b> (<b>GNFS</b>) is the most efficient classical algorithm known for factoring integers larger than <span class="texhtml ">10<sup>100</sup></span>. Heuristically, its complexity for factoring an integer <span class="texhtml mvar" style="font-style:italic">n</span> (consisting of <span class="texhtml ">\u230Alog<sub>2</sub> <span class="texhtml mvar" style="font-style:italic">n</span>\u230B + 1</span> bits) is of the form</p><dl><dd><span class="mwe-math-element"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/fcc5450b9f039008c0a728e15b6c66f24dafbb30" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align:-2.505ex;width:57.324ex;height:6.343ex" /></span></dd></dl>',ju='<a href="https://en.wikipedia.org/wiki/Exponential_function"><h3>Exponential function</h3></a><p>The <b>exponential function</b> is a mathematical function denoted by <span class="mwe-math-element"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/9dd9b17af32bc3cffe927507c7bccf4e2a96f585" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align:-0.838ex;width:14.207ex;height:2.843ex" /></span> or <span class="mwe-math-element"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/841c0d168e64191c45a45e54c7e447defd17ec6a" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align:-0.338ex;width:2.256ex;height:2.343ex" /></span>. Unless otherwise specified, the term generally refers to the positive-valued function of a real variable, although it can be extended to the complex numbers or generalized to other mathematical objects like matrices or Lie algebras. The exponential function originated from the notion of exponentiation, but modern definitions allow it to be rigorously extended to all real arguments, including irrational numbers. Its ubiquitous occurrence in pure and applied mathematics led mathematician Walter Rudin to opine that the exponential function is "the most important function in mathematics".</p>',Vu='<a href="https://en.wikipedia.org/wiki/Quantum_computing"><h3>Quantum computing</h3></a><p><b>Quantum computing</b> is a type of computation whose operations can harness the phenomena of quantum mechanics, such as superposition, interference, and entanglement. Devices that perform quantum computations are known as <b>quantum computers</b>. Though current quantum computers are too small to outperform usual (classical) computers for practical applications, larger realizations are believed to be capable of solving certain computational problems, such as integer factorization, substantially faster than classical computers. The study of quantum computing is a subfield of quantum information science.</p>',Uu=`<a href="https://en.wikipedia.org/wiki/Cubic_function"><h3>Cubic function</h3></a><p>In mathematics, a <b>cubic function</b> is a function of the form <span class="mwe-math-element"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/9cc573924b3e958061c7436c149efc76e4098668" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align:-0.838ex;width:26.585ex;height:3.176ex" /></span>
where the coefficients <span class="texhtml mvar" style="font-style:italic">a</span>, <span class="texhtml mvar" style="font-style:italic">b</span>, <span class="texhtml mvar" style="font-style:italic">c</span>, and <span class="texhtml mvar" style="font-style:italic">d</span> are complex numbers, and the variable <span class="texhtml mvar" style="font-style:italic">x</span> takes real values, and <span class="mwe-math-element"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f455a7f96d74aa94573d8e32da3b240ab0aa294f" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align:-0.838ex;width:5.491ex;height:2.676ex" /></span>. In other words, it is both a polynomial function of degree three, and a real function. In particular, the domain and the codomain are the set of the real numbers.</p>`,Gu='<a href="https://en.wikipedia.org/wiki/Computational_complexity"><h3 class="text-lg font-semibold">Computational complexity</h3></a><p>In computer science, the <b>computational complexity</b> or simply <b>complexity</b> of an algorithm is the amount of resources required to run it. Particular focus is given to time and memory requirements. The complexity of a problem is the complexity of the best algorithms that allow solving the problem.</p>',Ou=`<a href="https://en.wikipedia.org/wiki/Linear_function"><h3>Linear function</h3></a><p>In mathematics, the term <b>linear function</b> refers to two distinct but related notions:</p><ul><li>In calculus and related areas, a linear function is a function whose graph is a straight line, that is, a polynomial function of degree zero or one. For distinguishing such a linear function from the other concept, the term affine function is often used.</li>
<li>In linear algebra, mathematical analysis, and functional analysis, a linear function is a linear map.</li></ul>`;function Ku(e){let t;return{c(){t=h("semiprime")},l(r){t=f(r,"semiprime")},m(r,s){y(r,t,s)},d(r){r&&a(t)}}}function Zu(e){let t;return{c(){t=h("number field sieve")},l(r){t=f(r,"number field sieve")},m(r,s){y(r,t,s)},d(r){r&&a(t)}}}function Xu(e){let t;return{c(){t=h("exponentially")},l(r){t=f(r,"exponentially")},m(r,s){y(r,t,s)},d(r){r&&a(t)}}}function Yu(e){let t;return{c(){t=h("quantum computer")},l(r){t=f(r,"quantum computer")},m(r,s){y(r,t,s)},d(r){r&&a(t)}}}function Ju(e){let t;return{c(){t=h("cubically")},l(r){t=f(r,"cubically")},m(r,s){y(r,t,s)},d(r){r&&a(t)}}}function eh(e){let t;return{c(){t=h("Computational complexity")},l(r){t=f(r,"Computational complexity")},m(r,s){y(r,t,s)},d(r){r&&a(t)}}}function th(e){let t;return{c(){t=h("linearly")},l(r){t=f(r,"linearly")},m(r,s){y(r,t,s)},d(r){r&&a(t)}}}function nh(e){let t,r,s,o,c,_,m=p("p, q \\in \\mathbb{P}")+"",b,v,k,w,E=p("N \\in \\mathbb{N}")+"",N,Q,K=p("N = p \\cdot q")+"",V,L,z=p("15,")+"",x,H,I=p("3")+"",j,Y,P=p("5.")+"",re,X,D=p("62615533")+"",M,q,ee,B,R,U,ie,te,Ee,he,Z=p("100")+"",T,J,de=p("3")+"",We,be,je=p("200")+"",ne,ae,ye=p("5")+"",lt,we,fe,Ve,ut,He,ke,st,Ue,yt;return v=new Rt({props:{hovertext:Wu,$$slots:{default:[Ku]},$$scope:{ctx:e}}}),q=new Rt({props:{hovertext:zu,$$slots:{default:[Zu]},$$scope:{ctx:e}}}),B=new Rt({props:{hovertext:ju,$$slots:{default:[Xu]},$$scope:{ctx:e}}}),U=new Rt({props:{hovertext:Vu,$$slots:{default:[Yu]},$$scope:{ctx:e}}}),te=new Rt({props:{hovertext:Uu,$$slots:{default:[Ju]},$$scope:{ctx:e}}}),Ve=new Rt({props:{hovertext:Gu,$$slots:{default:[eh]},$$scope:{ctx:e}}}),He=new Rt({props:{hovertext:Ou,$$slots:{default:[th]},$$scope:{ctx:e}}}),{c(){t=i("h2"),r=h("Description of the problem"),s=S(),o=i("p"),c=h("We would like to find the prime factors "),_=i("span"),b=h(" of a large "),Le(v.$$.fragment),k=S(),w=i("span"),N=h(" (so that "),Q=i("span"),V=h("). Finding these factors for a small number, such as "),L=i("span"),x=h(" is quite easy. In fact, you may figure it out just by looking at it and recalling your grade school studies: the factors are "),H=i("span"),j=h(" and "),Y=i("span"),re=h(" But what are the prime factors of, say, "),X=i("span"),M=h("? It turns out that, using the best known classical (meaning non-quantum) algorithm (the so called "),Le(q.$$.fragment),ee=h("), solving the factoring problem scales "),Le(B.$$.fragment),R=h(" with the number of digits of the semiprime that we want to factor. With the help of Shor's algorithm and a sufficiently large "),Le(U.$$.fragment),ie=h(", the same problem scales roughly "),Le(te.$$.fragment),Ee=h(" with the number of digits. (In fact, the algorithm does slighly better than that, but the precise formula is a bit complicated and is beside the point.) To illustrate what this means in practical terms, imagine the following. If factoring a "),he=i("span"),T=h("-digit number with Shor's algorithm on a quantum computer takes one second, factoring the same number with the number field sieve on a classical computer takes more than "),J=i("span"),We=h(" hours. If we now try with a "),be=i("span"),ne=h("-digit number, Shor's algorithm finishes in roughly "),ae=i("span"),lt=h(" seconds, while the classical solution would take more than a year!"),we=S(),fe=i("p"),Le(Ve.$$.fragment),ut=h(` refers to how the time - or number of elementary operations - required to solve a given problem algorithmically grows with the size of the input. Let's say you have to find the longest book you have ever read. One way to approach this problem is to list the books you have read one by one, label the first one as the longest, and whenever you encounter an even longer book, it takes the place of the former. This way, you only have to keep track of the largest page number so far, and the book associated with it. The "elementary operation" in this case is checking the number of pages of the next book and comparing that with the previous maximum. If you have twice or three times as many books, this procedure requires twice or three times as many elementary operations. In other words, it grows `),Le(He.$$.fragment),ke=h(" in the number of books. So, while the solution can be found using the same algorithm, the number of elementary operations required to carry out that algorithm depends on the size of the input. This is true for almost all algorithms that are designed to solve mathematical problems. However, how fast that growth is, makes all the difference between them.")},l(G){t=l(G,"H2",{});var pe=u(t);r=f(pe,"Description of the problem"),pe.forEach(a),s=A(G),o=l(G,"P",{});var le=u(o);c=f(le,"We would like to find the prime factors "),_=l(le,"SPAN",{});var Lt=u(_);Lt.forEach(a),b=f(le," of a large "),qe(v.$$.fragment,le),k=A(le),w=l(le,"SPAN",{});var Ge=u(w);Ge.forEach(a),N=f(le," (so that "),Q=l(le,"SPAN",{});var Nt=u(Q);Nt.forEach(a),V=f(le,"). Finding these factors for a small number, such as "),L=l(le,"SPAN",{});var qt=u(L);qt.forEach(a),x=f(le," is quite easy. In fact, you may figure it out just by looking at it and recalling your grade school studies: the factors are "),H=l(le,"SPAN",{});var Oe=u(H);Oe.forEach(a),j=f(le," and "),Y=l(le,"SPAN",{});var $t=u(Y);$t.forEach(a),re=f(le," But what are the prime factors of, say, "),X=l(le,"SPAN",{});var kn=u(X);kn.forEach(a),M=f(le,"? It turns out that, using the best known classical (meaning non-quantum) algorithm (the so called "),qe(q.$$.fragment,le),ee=f(le,"), solving the factoring problem scales "),qe(B.$$.fragment,le),R=f(le," with the number of digits of the semiprime that we want to factor. With the help of Shor's algorithm and a sufficiently large "),qe(U.$$.fragment,le),ie=f(le,", the same problem scales roughly "),qe(te.$$.fragment,le),Ee=f(le," with the number of digits. (In fact, the algorithm does slighly better than that, but the precise formula is a bit complicated and is beside the point.) To illustrate what this means in practical terms, imagine the following. If factoring a "),he=l(le,"SPAN",{});var Je=u(he);Je.forEach(a),T=f(le,"-digit number with Shor's algorithm on a quantum computer takes one second, factoring the same number with the number field sieve on a classical computer takes more than "),J=l(le,"SPAN",{});var Jt=u(J);Jt.forEach(a),We=f(le," hours. If we now try with a "),be=l(le,"SPAN",{});var Tn=u(be);Tn.forEach(a),ne=f(le,"-digit number, Shor's algorithm finishes in roughly "),ae=l(le,"SPAN",{});var et=u(ae);et.forEach(a),lt=f(le," seconds, while the classical solution would take more than a year!"),le.forEach(a),we=A(G),fe=l(G,"P",{});var pt=u(fe);qe(Ve.$$.fragment,pt),ut=f(pt,` refers to how the time - or number of elementary operations - required to solve a given problem algorithmically grows with the size of the input. Let's say you have to find the longest book you have ever read. One way to approach this problem is to list the books you have read one by one, label the first one as the longest, and whenever you encounter an even longer book, it takes the place of the former. This way, you only have to keep track of the largest page number so far, and the book associated with it. The "elementary operation" in this case is checking the number of pages of the next book and comparing that with the previous maximum. If you have twice or three times as many books, this procedure requires twice or three times as many elementary operations. In other words, it grows `),qe(He.$$.fragment,pt),ke=f(pt," in the number of books. So, while the solution can be found using the same algorithm, the number of elementary operations required to carry out that algorithm depends on the size of the input. This is true for almost all algorithms that are designed to solve mathematical problems. However, how fast that growth is, makes all the difference between them."),pt.forEach(a)},m(G,pe){y(G,t,pe),n(t,r),y(G,s,pe),y(G,o,pe),n(o,c),n(o,_),_.innerHTML=m,n(o,b),xe(v,o,null),n(o,k),n(o,w),w.innerHTML=E,n(o,N),n(o,Q),Q.innerHTML=K,n(o,V),n(o,L),L.innerHTML=z,n(o,x),n(o,H),H.innerHTML=I,n(o,j),n(o,Y),Y.innerHTML=P,n(o,re),n(o,X),X.innerHTML=D,n(o,M),xe(q,o,null),n(o,ee),xe(B,o,null),n(o,R),xe(U,o,null),n(o,ie),xe(te,o,null),n(o,Ee),n(o,he),he.innerHTML=Z,n(o,T),n(o,J),J.innerHTML=de,n(o,We),n(o,be),be.innerHTML=je,n(o,ne),n(o,ae),ae.innerHTML=ye,n(o,lt),y(G,we,pe),y(G,fe,pe),xe(Ve,fe,null),n(fe,ut),xe(He,fe,null),n(fe,ke),st=!0,Ue||(yt=[d(_,"mouseenter",e[0]),d(w,"mouseenter",e[1]),d(Q,"mouseenter",e[2]),d(L,"mouseenter",e[3]),d(H,"mouseenter",e[4]),d(Y,"mouseenter",e[5]),d(X,"mouseenter",e[6]),d(he,"mouseenter",e[7]),d(J,"mouseenter",e[8]),d(be,"mouseenter",e[9]),d(ae,"mouseenter",e[10])],Ue=!0)},p(G,[pe]){const le={};pe&2048&&(le.$$scope={dirty:pe,ctx:G}),v.$set(le);const Lt={};pe&2048&&(Lt.$$scope={dirty:pe,ctx:G}),q.$set(Lt);const Ge={};pe&2048&&(Ge.$$scope={dirty:pe,ctx:G}),B.$set(Ge);const Nt={};pe&2048&&(Nt.$$scope={dirty:pe,ctx:G}),U.$set(Nt);const qt={};pe&2048&&(qt.$$scope={dirty:pe,ctx:G}),te.$set(qt);const Oe={};pe&2048&&(Oe.$$scope={dirty:pe,ctx:G}),Ve.$set(Oe);const $t={};pe&2048&&($t.$$scope={dirty:pe,ctx:G}),He.$set($t)},i(G){st||(Pe(v.$$.fragment,G),Pe(q.$$.fragment,G),Pe(B.$$.fragment,G),Pe(U.$$.fragment,G),Pe(te.$$.fragment,G),Pe(Ve.$$.fragment,G),Pe(He.$$.fragment,G),st=!0)},o(G){Se(v.$$.fragment,G),Se(q.$$.fragment,G),Se(B.$$.fragment,G),Se(U.$$.fragment,G),Se(te.$$.fragment,G),Se(Ve.$$.fragment,G),Se(He.$$.fragment,G),st=!1},d(G){G&&a(t),G&&a(s),G&&a(o),Ie(v),Ie(q),Ie(B),Ie(U),Ie(te),G&&a(we),G&&a(fe),Ie(Ve),Ie(He),Ue=!1,es(yt)}}}function Fa(e){console.log(e)}function ah(e){return[()=>Fa(["p","q","P"]),()=>Fa(["N"]),()=>Fa(["N","q","p"]),()=>Fa([]),()=>Fa([]),()=>Fa([]),()=>Fa([]),()=>Fa([]),()=>Fa([]),()=>Fa([]),()=>Fa([])]}class rh extends va{constructor(t){super(),ba(this,t,ah,nh,ga,{})}}const sh='<a href="https://en.wikipedia.org/wiki/Greatest_common_divisor"><h3>Greatest common divisor</h3></a><p>In mathematics, the <b>greatest common divisor</b> (<b>GCD</b>) of two or more integers, which are not all zero, is the largest positive integer that divides each of the integers. For two integers <i>x</i>, <i>y</i>, the greatest common divisor of <i>x</i> and <i>y</i> is denoted <span class="mwe-math-element"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/24c083a217bb5e2d3468e683c957f220a683e4d8" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align:-0.838ex;width:8.816ex;height:2.843ex" /></span>. For example, the GCD of 8 and 12 is 4, that is, <span class="mwe-math-element"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/cabed257e6ea789ef3febd9add3a7f3ef2237361" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align:-0.838ex;width:14.079ex;height:2.843ex" /></span>.</p>',oh=`<a href="https://en.wikipedia.org/wiki/Euclidean_algorithm"><h3>Euclidean algorithm</h3></a><p>In mathematics, the <b>Euclidean algorithm</b>, or <b>Euclid's algorithm</b>, is an efficient method for computing the greatest common divisor (GCD) of two integers (numbers), the largest number that divides them both without a remainder. It is named after the ancient Greek mathematician Euclid, who first described it in <span>his <i>Elements</i></span> .
It is an example of an <i>algorithm</i>, a step-by-step procedure for performing a calculation according to well-defined rules,
and is one of the oldest algorithms in common use. It can be used to reduce fractions to their simplest form, and is a part of many other number-theoretic and cryptographic calculations.</p>`;function ih(e){let t;return{c(){t=h("greatest common divisor")},l(r){t=f(r,"greatest common divisor")},m(r,s){y(r,t,s)},d(r){r&&a(t)}}}function lh(e){let t;return{c(){t=h("Euclid's algorithm")},l(r){t=f(r,"Euclid's algorithm")},m(r,s){y(r,t,s)},d(r){r&&a(t)}}}function uh(e){let t,r,s,o,c,_,m,b,v,k,w,E=p("a \\in \\mathbb{N}, 1 < a < N")+"",N,Q,K=p("a")+"",V,L,z=p("N")+"",x,H,I=p("\\gcd(a, N) = 1,")+"",j,Y,P=p("\\gcd")+"",re,X,D,M,q=p("a")+"",ee,B,R=p("N,")+"",U,ie,te=p("N")+"",Ee,he,Z,T,J,de,We=p("f_{a, N}(r): \\mathbb{N} \\rightarrow \\mathbb{N} = a^r \\mod N")+"",be,je,ne=p("0 < \\hat{r} < N")+"",ae,ye,lt=p("f_{a, N}(\\hat{r}) = 1.")+"",we,fe,Ve=p("\\hat{r}")+"",ut,He,ke=p("a")+"",st,Ue,yt,G,pe,le,Lt=p("\\hat{r}")+"",Ge,Nt,qt=p("\\hat{r}")+"",Oe,$t,kn=p("m \\in \\mathbb{N}")+"",Je,Jt,Tn=p("a^{\\hat{r}} = m \\cdot N + 1.")+"",et,pt,On=p("b = a^{\\frac{\\hat{r}}{2}},")+"",Be,en,tn=p("b^2 = (a^{\\frac{\\hat{r}}{2}})^2 = a^{\\hat{r}}.")+"",nn,an,rn=p("b^2 - 1 = (b + 1)(b - 1).")+"",Mn,Pn,sn=p("(b + 1)(b - 1) = m \\cdot N.")+"",Bt,on,oe,ts,ln,ya=p("N")+"",ge,un,Sn=p("(b - 1) \\mod N \\neq 0,")+"",Kn,hn,An=p("b = a^{\\frac{\\hat{r}}{2}} \\mod N = 1,")+"",_t,fn,Dt=p("\\hat{r}")+"",ns,mn,Wt=p("\\frac{\\hat{r}}{2} < \\hat{r}")+"",as,pn,zt=p("(b + 1) \\mod N = 0,")+"",rs,_n,Hn=p("a")+"",ht,cn,jt=p("(b + 1) \\mod N \\neq 0,")+"",ss,dn,Vt=p("\\gcd(b - 1, N)")+"",os,wn,Ut=p("\\gcd(b + 1, N),")+"",is,xt,Et,Ra,Ca=p("(b - 1)")+"",kt,Zn,Ba=p("(b + 1)")+"",Ze,Tt,Xn=p("N,")+"",Da,ft,Yn=p("m \\cdot N")+"",Jn,ea,ta=p("N,")+"",Wa,Gt,Xe,ls,It,Ae,Na,ct,dt,$a,wt,za=p("\\hat{r},")+"",vn,Ot,Pr=p("1")+"",me,Mt,ja=p("N")+"",gr,Pt,Va=p("N")+"",yr,Kt,na,Sr;return X=new Rt({props:{hovertext:sh,$$slots:{default:[ih]},$$scope:{ctx:e}}}),xt=new Rt({props:{hovertext:oh,$$slots:{default:[lh]},$$scope:{ctx:e}}}),{c(){t=i("h2"),r=h("Solution"),s=S(),o=i("p"),c=h("The factoring problem can be solved with the following simple, but very time-consuming algorithm:"),_=S(),m=i("ol"),b=i("li"),v=i("p"),k=h("We pick a random number "),w=i("span"),N=h(" and make sure that "),Q=i("span"),V=h(" and "),L=i("span"),x=h(" are relative primes, meaning "),H=i("span"),j=h(" where "),Y=i("span"),re=h(" stands for "),Le(X.$$.fragment),D=h(". (In case "),M=i("span"),ee=h(" happens to be a factor of "),B=i("span"),U=h(" the entire problem is solved and no further steps are required, but that is highly unlikely if "),ie=i("span"),Ee=h(" is large.)"),he=S(),Z=i("li"),T=i("p"),J=h("Next, we construct the function "),de=i("span"),be=h(" and find the smallest integer "),je=i("span"),ae=h(" such that "),ye=i("span"),we=h(" If "),fe=i("span"),ut=h(" turns out to be odd, we unfortunately have to repeat the entire procedure with a different "),He=i("span"),st=h(" parameter."),Ue=S(),yt=i("li"),G=i("p"),pe=h("If we're lucky and "),le=i("span"),Ge=h(" is even, we can proceed. From the definition of "),Nt=i("span"),Oe=h(" follows that there's "),$t=i("span"),Je=h(" such that "),Jt=i("span"),et=h(" We can then define the integer "),pt=i("span"),Be=h(" which means "),en=i("span"),nn=h(" Next, we make use of a well-known algebraic identity to write "),an=i("span"),Mn=h(" Putting together these three equations, we find that "),Pn=i("span"),Bt=S(),on=i("li"),oe=i("p"),ts=h("For this step, we need to make sure that neither terms on the left of the expression above are divisible by "),ln=i("span"),ge=h(". Note that we know for sure "),un=i("span"),Kn=h(" because that would imply "),hn=i("span"),_t=h(" and we defined "),fn=i("span"),ns=h(" as the smallest positive integer, for which that equality holds, so it cannot hold for "),mn=i("span"),as=h(". Unfortunately, we cannot guarantee the same for the other term, so if "),pn=i("span"),rs=h(" we have to choose a new "),_n=i("span"),ht=h(" and start from the beginning. If "),cn=i("span"),ss=h(" however, we have solved the problem, because the prime factors we're looking for are "),dn=i("span"),os=h(" and "),wn=i("span"),is=h(" and these are very easy to compute with the help of "),Le(xt.$$.fragment),Et=h(". To see why this is true, consider the following. We have established that neither "),Ra=i("span"),kt=h(" nor "),Zn=i("span"),Ze=h(" are divisible by "),Tt=i("span"),Da=h(" but their product is, as it equals "),ft=i("span"),Jn=h(". This is only possible, if both of them share a factor with "),ea=i("span"),Wa=h(" and the factors they share are different."),Gt=S(),Xe=i("p"),ls=h("If you're not entirely satisfied with the explanation above, check out the video "),It=i("a"),Ae=h("Hacking at Quantum Speed with Shor's Algorithm"),Na=h(" by PBS Infinite Series."),ct=S(),dt=i("p"),$a=h("The problem with this solution is that in order to find "),wt=i("span"),vn=h(" we might have to check all possible values between "),Ot=i("span"),me=h(" and "),Mt=i("span"),gr=h(" one after the other, which is an insane amount of computation if "),Pt=i("span"),yr=h(" is number with several hundreds of digits. But that's only the case if we're trying with a classical computer."),this.h()},l(ue){t=l(ue,"H2",{});var ze=u(t);r=f(ze,"Solution"),ze.forEach(a),s=A(ue),o=l(ue,"P",{});var aa=u(o);c=f(aa,"The factoring problem can be solved with the following simple, but very time-consuming algorithm:"),aa.forEach(a),_=A(ue),m=l(ue,"OL",{});var Ye=u(m);b=l(Ye,"LI",{});var Ln=u(b);v=l(Ln,"P",{});var De=u(v);k=f(De,"We pick a random number "),w=l(De,"SPAN",{});var Fe=u(w);Fe.forEach(a),N=f(De," and make sure that "),Q=l(De,"SPAN",{});var ra=u(Q);ra.forEach(a),V=f(De," and "),L=l(De,"SPAN",{});var Ua=u(L);Ua.forEach(a),x=f(De," are relative primes, meaning "),H=l(De,"SPAN",{});var us=u(H);us.forEach(a),j=f(De," where "),Y=l(De,"SPAN",{});var sa=u(Y);sa.forEach(a),re=f(De," stands for "),qe(X.$$.fragment,De),D=f(De,". (In case "),M=l(De,"SPAN",{});var Ga=u(M);Ga.forEach(a),ee=f(De," happens to be a factor of "),B=l(De,"SPAN",{});var hs=u(B);hs.forEach(a),U=f(De," the entire problem is solved and no further steps are required, but that is highly unlikely if "),ie=l(De,"SPAN",{});var oa=u(ie);oa.forEach(a),Ee=f(De," is large.)"),De.forEach(a),Ln.forEach(a),he=A(Ye),Z=l(Ye,"LI",{});var Ea=u(Z);T=l(Ea,"P",{});var vt=u(T);J=f(vt,"Next, we construct the function "),de=l(vt,"SPAN",{});var ia=u(de);ia.forEach(a),be=f(vt," and find the smallest integer "),je=l(vt,"SPAN",{});var Oa=u(je);Oa.forEach(a),ae=f(vt," such that "),ye=l(vt,"SPAN",{});var fs=u(ye);fs.forEach(a),we=f(vt," If "),fe=l(vt,"SPAN",{});var la=u(fe);la.forEach(a),ut=f(vt," turns out to be odd, we unfortunately have to repeat the entire procedure with a different "),He=l(vt,"SPAN",{});var Ka=u(He);Ka.forEach(a),st=f(vt," parameter."),vt.forEach(a),Ea.forEach(a),Ue=A(Ye),yt=l(Ye,"LI",{});var Ar=u(yt);G=l(Ar,"P",{});var Ce=u(G);pe=f(Ce,"If we're lucky and "),le=l(Ce,"SPAN",{});var Za=u(le);Za.forEach(a),Ge=f(Ce," is even, we can proceed. From the definition of "),Nt=l(Ce,"SPAN",{});var ms=u(Nt);ms.forEach(a),Oe=f(Ce," follows that there's "),$t=l(Ce,"SPAN",{});var ua=u($t);ua.forEach(a),Je=f(Ce," such that "),Jt=l(Ce,"SPAN",{});var Xa=u(Jt);Xa.forEach(a),et=f(Ce," We can then define the integer "),pt=l(Ce,"SPAN",{});var ps=u(pt);ps.forEach(a),Be=f(Ce," which means "),en=l(Ce,"SPAN",{});var ha=u(en);ha.forEach(a),nn=f(Ce," Next, we make use of a well-known algebraic identity to write "),an=l(Ce,"SPAN",{});var Ya=u(an);Ya.forEach(a),Mn=f(Ce," Putting together these three equations, we find that "),Pn=l(Ce,"SPAN",{});var _s=u(Pn);_s.forEach(a),Ce.forEach(a),Ar.forEach(a),Bt=A(Ye),on=l(Ye,"LI",{});var qn=u(on);oe=l(qn,"P",{});var _e=u(oe);ts=f(_e,"For this step, we need to make sure that neither terms on the left of the expression above are divisible by "),ln=l(_e,"SPAN",{});var cs=u(ln);cs.forEach(a),ge=f(_e,". Note that we know for sure "),un=l(_e,"SPAN",{});var xn=u(un);xn.forEach(a),Kn=f(_e," because that would imply "),hn=l(_e,"SPAN",{});var St=u(hn);St.forEach(a),_t=f(_e," and we defined "),fn=l(_e,"SPAN",{});var Nr=u(fn);Nr.forEach(a),ns=f(_e," as the smallest positive integer, for which that equality holds, so it cannot hold for "),mn=l(_e,"SPAN",{});var Zt=u(mn);Zt.forEach(a),as=f(_e,". Unfortunately, we cannot guarantee the same for the other term, so if "),pn=l(_e,"SPAN",{});var to=u(pn);to.forEach(a),rs=f(_e," we have to choose a new "),_n=l(_e,"SPAN",{});var $r=u(_n);$r.forEach(a),ht=f(_e," and start from the beginning. If "),cn=l(_e,"SPAN",{});var In=u(cn);In.forEach(a),ss=f(_e," however, we have solved the problem, because the prime factors we're looking for are "),dn=l(_e,"SPAN",{});var Ja=u(dn);Ja.forEach(a),os=f(_e," and "),wn=l(_e,"SPAN",{});var Er=u(wn);Er.forEach(a),is=f(_e," and these are very easy to compute with the help of "),qe(xt.$$.fragment,_e),Et=f(_e,". To see why this is true, consider the following. We have established that neither "),Ra=l(_e,"SPAN",{});var Fn=u(Ra);Fn.forEach(a),kt=f(_e," nor "),Zn=l(_e,"SPAN",{});var er=u(Zn);er.forEach(a),Ze=f(_e," are divisible by "),Tt=l(_e,"SPAN",{});var fa=u(Tt);fa.forEach(a),Da=f(_e," but their product is, as it equals "),ft=l(_e,"SPAN",{});var tr=u(ft);tr.forEach(a),Jn=f(_e,". This is only possible, if both of them share a factor with "),ea=l(_e,"SPAN",{});var Hr=u(ea);Hr.forEach(a),Wa=f(_e," and the factors they share are different."),_e.forEach(a),qn.forEach(a),Ye.forEach(a),Gt=A(ue),Xe=l(ue,"P",{});var ot=u(Xe);ls=f(ot,"If you're not entirely satisfied with the explanation above, check out the video "),It=l(ot,"A",{href:!0});var Qn=u(It);Ae=f(Qn,"Hacking at Quantum Speed with Shor's Algorithm"),Qn.forEach(a),Na=f(ot," by PBS Infinite Series."),ot.forEach(a),ct=A(ue),dt=l(ue,"P",{});var tt=u(dt);$a=f(tt,"The problem with this solution is that in order to find "),wt=l(tt,"SPAN",{});var Lr=u(wt);Lr.forEach(a),vn=f(tt," we might have to check all possible values between "),Ot=l(tt,"SPAN",{});var ce=u(Ot);ce.forEach(a),me=f(tt," and "),Mt=l(tt,"SPAN",{});var ma=u(Mt);ma.forEach(a),gr=f(tt," one after the other, which is an insane amount of computation if "),Pt=l(tt,"SPAN",{});var nr=u(Pt);nr.forEach(a),yr=f(tt," is number with several hundreds of digits. But that's only the case if we're trying with a classical computer."),tt.forEach(a),this.h()},h(){F(It,"href","https://www.youtube.com/watch?v=wUwZZaI5u0c&t=731s")},m(ue,ze){y(ue,t,ze),n(t,r),y(ue,s,ze),y(ue,o,ze),n(o,c),y(ue,_,ze),y(ue,m,ze),n(m,b),n(b,v),n(v,k),n(v,w),w.innerHTML=E,n(v,N),n(v,Q),Q.innerHTML=K,n(v,V),n(v,L),L.innerHTML=z,n(v,x),n(v,H),H.innerHTML=I,n(v,j),n(v,Y),Y.innerHTML=P,n(v,re),xe(X,v,null),n(v,D),n(v,M),M.innerHTML=q,n(v,ee),n(v,B),B.innerHTML=R,n(v,U),n(v,ie),ie.innerHTML=te,n(v,Ee),n(m,he),n(m,Z),n(Z,T),n(T,J),n(T,de),de.innerHTML=We,n(T,be),n(T,je),je.innerHTML=ne,n(T,ae),n(T,ye),ye.innerHTML=lt,n(T,we),n(T,fe),fe.innerHTML=Ve,n(T,ut),n(T,He),He.innerHTML=ke,n(T,st),n(m,Ue),n(m,yt),n(yt,G),n(G,pe),n(G,le),le.innerHTML=Lt,n(G,Ge),n(G,Nt),Nt.innerHTML=qt,n(G,Oe),n(G,$t),$t.innerHTML=kn,n(G,Je),n(G,Jt),Jt.innerHTML=Tn,n(G,et),n(G,pt),pt.innerHTML=On,n(G,Be),n(G,en),en.innerHTML=tn,n(G,nn),n(G,an),an.innerHTML=rn,n(G,Mn),n(G,Pn),Pn.innerHTML=sn,n(m,Bt),n(m,on),n(on,oe),n(oe,ts),n(oe,ln),ln.innerHTML=ya,n(oe,ge),n(oe,un),un.innerHTML=Sn,n(oe,Kn),n(oe,hn),hn.innerHTML=An,n(oe,_t),n(oe,fn),fn.innerHTML=Dt,n(oe,ns),n(oe,mn),mn.innerHTML=Wt,n(oe,as),n(oe,pn),pn.innerHTML=zt,n(oe,rs),n(oe,_n),_n.innerHTML=Hn,n(oe,ht),n(oe,cn),cn.innerHTML=jt,n(oe,ss),n(oe,dn),dn.innerHTML=Vt,n(oe,os),n(oe,wn),wn.innerHTML=Ut,n(oe,is),xe(xt,oe,null),n(oe,Et),n(oe,Ra),Ra.innerHTML=Ca,n(oe,kt),n(oe,Zn),Zn.innerHTML=Ba,n(oe,Ze),n(oe,Tt),Tt.innerHTML=Xn,n(oe,Da),n(oe,ft),ft.innerHTML=Yn,n(oe,Jn),n(oe,ea),ea.innerHTML=ta,n(oe,Wa),y(ue,Gt,ze),y(ue,Xe,ze),n(Xe,ls),n(Xe,It),n(It,Ae),n(Xe,Na),y(ue,ct,ze),y(ue,dt,ze),n(dt,$a),n(dt,wt),wt.innerHTML=za,n(dt,vn),n(dt,Ot),Ot.innerHTML=Pr,n(dt,me),n(dt,Mt),Mt.innerHTML=ja,n(dt,gr),n(dt,Pt),Pt.innerHTML=Va,n(dt,yr),Kt=!0,na||(Sr=[d(w,"mouseenter",e[0]),d(Q,"mouseenter",e[1]),d(L,"mouseenter",e[2]),d(H,"mouseenter",e[3]),d(Y,"mouseenter",e[4]),d(M,"mouseenter",e[5]),d(B,"mouseenter",e[6]),d(ie,"mouseenter",e[7]),d(de,"mouseenter",e[8]),d(je,"mouseenter",e[9]),d(ye,"mouseenter",e[10]),d(fe,"mouseenter",e[11]),d(He,"mouseenter",e[12]),d(le,"mouseenter",e[13]),d(Nt,"mouseenter",e[14]),d($t,"mouseenter",e[15]),d(Jt,"mouseenter",e[16]),d(pt,"mouseenter",e[17]),d(en,"mouseenter",e[18]),d(an,"mouseenter",e[19]),d(Pn,"mouseenter",e[20]),d(ln,"mouseenter",e[21]),d(un,"mouseenter",e[22]),d(hn,"mouseenter",e[23]),d(fn,"mouseenter",e[24]),d(mn,"mouseenter",e[25]),d(pn,"mouseenter",e[26]),d(_n,"mouseenter",e[27]),d(cn,"mouseenter",e[28]),d(dn,"mouseenter",e[29]),d(wn,"mouseenter",e[30]),d(Ra,"mouseenter",e[31]),d(Zn,"mouseenter",e[32]),d(Tt,"mouseenter",e[33]),d(ft,"mouseenter",e[34]),d(ea,"mouseenter",e[35]),d(wt,"mouseenter",e[36]),d(Ot,"mouseenter",e[37]),d(Mt,"mouseenter",e[38]),d(Pt,"mouseenter",e[39])],na=!0)},p(ue,ze){const aa={};ze[1]&512&&(aa.$$scope={dirty:ze,ctx:ue}),X.$set(aa);const Ye={};ze[1]&512&&(Ye.$$scope={dirty:ze,ctx:ue}),xt.$set(Ye)},i(ue){Kt||(Pe(X.$$.fragment,ue),Pe(xt.$$.fragment,ue),Kt=!0)},o(ue){Se(X.$$.fragment,ue),Se(xt.$$.fragment,ue),Kt=!1},d(ue){ue&&a(t),ue&&a(s),ue&&a(o),ue&&a(_),ue&&a(m),Ie(X),Ie(xt),ue&&a(Gt),ue&&a(Xe),ue&&a(ct),ue&&a(dt),na=!1,es(Sr)}}}function ve(e){console.log(e)}function hh(e){return[()=>ve(["a","N"]),()=>ve(["a"]),()=>ve(["N"]),()=>ve(["a","N"]),()=>ve([]),()=>ve(["a"]),()=>ve(["N"]),()=>ve(["N"]),()=>ve(["f","a","N","r"]),()=>ve(["N","r"]),()=>ve(["f","a","N","r"]),()=>ve(["r"]),()=>ve(["a"]),()=>ve(["r"]),()=>ve(["r"]),()=>ve(["N","m"]),()=>ve(["a","N","m","r"]),()=>ve(["a","b","r"]),()=>ve(["a","b","r"]),()=>ve(["b"]),()=>ve(["N","b","m"]),()=>ve(["N"]),()=>ve(["N","b"]),()=>ve(["a","b","r","N"]),()=>ve(["r"]),()=>ve(["r"]),()=>ve(["N","b"]),()=>ve(["a"]),()=>ve(["N","b"]),()=>ve(["N","b"]),()=>ve(["N","b"]),()=>ve(["b"]),()=>ve(["b"]),()=>ve(["N"]),()=>ve(["N","m"]),()=>ve(["N"]),()=>ve(["r"]),()=>ve([]),()=>ve(["N"]),()=>ve(["N"])]}class fh extends va{constructor(t){super(),ba(this,t,hh,uh,ga,{},null,[-1,-1])}}function mh(e){let t,r,s,o,c,_,m,b,v,k;return o=new rh({}),_=new fh({}),v=new Du({}),{c(){t=i("h2"),r=h("Factoring"),s=S(),Le(o.$$.fragment),c=S(),Le(_.$$.fragment),m=S(),b=i("div"),Le(v.$$.fragment),this.h()},l(w){t=l(w,"H2",{});var E=u(t);r=f(E,"Factoring"),E.forEach(a),s=A(w),qe(o.$$.fragment,w),c=A(w),qe(_.$$.fragment,w),m=A(w),b=l(w,"DIV",{class:!0});var N=u(b);qe(v.$$.fragment,N),N.forEach(a),this.h()},h(){F(b,"class","interaction")},m(w,E){y(w,t,E),n(t,r),y(w,s,E),xe(o,w,E),y(w,c,E),xe(_,w,E),y(w,m,E),y(w,b,E),xe(v,b,null),k=!0},p:Js,i(w){k||(Pe(o.$$.fragment,w),Pe(_.$$.fragment,w),Pe(v.$$.fragment,w),k=!0)},o(w){Se(o.$$.fragment,w),Se(_.$$.fragment,w),Se(v.$$.fragment,w),k=!1},d(w){w&&a(t),w&&a(s),Ie(o,w),w&&a(c),Ie(_,w),w&&a(m),w&&a(b),Ie(v)}}}class ph extends va{constructor(t){super(),ba(this,t,null,mh,ga,{})}}const _h='<a href="https://en.wikipedia.org/wiki/Binary_number"><h3>Binary number</h3></a><p>A <b>binary number</b> is a number expressed in the <b>base-2 numeral system</b> or <b>binary numeral system</b>, a method of mathematical expression which uses only two symbols: typically "0" (zero) and "1" (one).</p>',ch=`<a href="https://en.wikipedia.org/wiki/Quantum_Fourier_transform"><h3>Quantum Fourier transform</h3></a><p>In quantum computing, the <b>quantum Fourier transform (QFT)</b> is a linear transformation on quantum bits, and is the quantum analogue of the discrete Fourier transform. The quantum Fourier transform is a part of many quantum algorithms, notably Shor's algorithm for factoring and computing the discrete logarithm, the quantum phase estimation algorithm for estimating the eigenvalues of a unitary operator, and algorithms for the hidden subgroup problem. The quantum Fourier transform was discovered by Don Coppersmith.</p>`;function dh(e){let t;return{c(){t=h("binary representations")},l(r){t=f(r,"binary representations")},m(r,s){y(r,t,s)},d(r){r&&a(t)}}}function wh(e){let t;return{c(){t=h("quantum Fourier transform")},l(r){t=f(r,"quantum Fourier transform")},m(r,s){y(r,t,s)},d(r){r&&a(t)}}}function vh(e){let t,r,s,o,c,_,m,b,v,k=p("n")+"",w,E,N=p("|0\\rangle")+"",Q,K,V=p("|1\\rangle.")+"",L,z,x=p("\\underbrace{2 \\cdot \\ldots \\cdot 2}_\\text{n times} = 2^n")+"",H,I,j=p("N := 2^n.")+"",Y,P,re,X,D,M,q=p("0")+"",ee,B,R=p("N - 1.")+"",U,ie,te=p("n = 5")+"",Ee,he,Z=p("|0\\rangle \\otimes |1\\rangle \\otimes |0\\rangle \\otimes |0\\rangle \\otimes |1\\rangle.")+"",T,J,de=p("01001,")+"",We,be,je=p("\\small 0 \\cdot 2^4 + 1 \\cdot 2^3 + 0 \\cdot 2^2 + 0 \\cdot 2^1 + 1 \\cdot 2^0 = 0 + 8 + 0 + 0 + 1 = 9.")+"",ne,ae,ye,lt,we,fe,Ve,ut,He,ke=p("x")+"",st,Ue,yt=p("x = 9")+"",G,pe,le=p("k")+"",Lt,Ge,Nt=p("\\frac{1}{\\sqrt{2}} \\left( |0\\rangle + e^{\\frac{2 \\pi i x}{2^k}} |1\\rangle \\right).")+"",qt,Oe,$t=p("\\alpha_k = \\frac{1}{\\sqrt{2}}")+"",kn,Je,Jt=p("\\beta_k = \\frac{1}{\\sqrt{2}} e^{\\frac{2 \\pi i x}{2^k}}")+"",Tn,et,pt=p("k = 1, ..., n.")+"",On,Be,en,tn,nn=p("\\alpha_k \\neq \\beta_k,")+"",an,rn,Mn=p("\\Vert{\\alpha_k}\\Vert^2 = \\Vert{\\beta_k}\\Vert^2 = \\frac{1}{2}")+"",Pn,sn,Bt=p("k = 1, ..., n.")+"",on,oe,ts=p("e^{\\frac{2 \\pi i x}{2^k}}")+"",ln,ya,ge,un,Sn,Kn=p("|0\\rangle")+"",hn,An,_t=p("|1\\rangle,")+"",fn,Dt,ns=p("n")+"",mn,Wt,as=p("n")+"",pn,zt,rs=p("0")+"",_n,Hn,ht=p("N - 1.")+"",cn,jt,ss=p("n")+"",dn,Vt,os=p("2^n")+"",wn,Ut,is=p("\\frac{1}{2}")+"",xt,Et,Ra=p("n")+"",Ca,kt,Zn=p("\\underbrace{\\frac{1}{2} \\cdot \\ldots \\cdot \\frac{1}{2}}_\\text{n terms} = \\frac{1}{2^n} = \\frac{1}{N}.")+"",Ba,Ze,Tt,Xn,Da,ft,Yn,Jn,ea=p("|\\psi\\rangle")+"",ta,Wa,Gt,Xe,ls=p("|\\psi\\rangle = \\underbrace{ \\frac{1}{\\sqrt{2}} \\left( |0\\rangle + e^{ \\frac{2 \\pi i x}{2^1} } |1\\rangle \\right) \\otimes \\ldots \\otimes \\frac{1}{\\sqrt{2}} \\left( |0\\rangle + e^{ \\frac{2 \\pi i x}{2^n} } |1\\rangle \\right) }_\\text{n terms}")+"",It,Ae,Na,ct,dt=p("\\frac{1}{\\sqrt{2}}")+"",$a,wt,za,vn,Ot=p("|\\psi\\rangle = \\frac{1}{\\sqrt{2^n}} \\left(\\left( |0\\rangle + e^{\\frac{2 \\pi i x}{2^1}} |1\\rangle \\right) \\otimes \\ldots \\otimes \\left( |0\\rangle + e^{\\frac{2 \\pi i x}{2^n}} |1\\rangle \\right) \\right) = \\frac{1}{\\sqrt{N}} \\left(\\left( |0\\rangle + e^{\\frac{2 \\pi i x}{2^1}} |1\\rangle \\right) \\otimes \\ldots \\otimes \\left( |0\\rangle + e^{\\frac{2 \\pi i x}{2^n}} |1\\rangle \\right) \\right)")+"",Pr,me,Mt,ja,gr=p("y")+"",Pt,Va,yr=p("n")+"",Kt,na,Sr=p("y_k")+"",ue,ze,aa=p("k")+"",Ye,Ln,De=p("y.")+"",Fe,ra,Ua=p("y_k = 0")+"",us,sa,Ga=p("k")+"",hs,oa,Ea=p("|0\\rangle")+"",vt,ia,Oa=p("y_k = 1")+"",fs,la,Ka=p("|1\\rangle")+"",Ar,Ce,Za=p("k = 1, \\ldots, n.")+"",ms,ua,Xa=p("y")+"",ps,ha,Ya=p("\\displaystyle{ y = \\sum_{k=1}^n y_k \\cdot 2^{n - k}}.")+"",_s,qn,_e=p("2^n")+"",cs,xn,St=p("k")+"",Nr,Zt,to=p("\\displaystyle{ y = 2^n \\cdot \\sum_{k=1}^n y_k \\cdot 2^{-k} = N \\cdot \\sum_{k=1}^n \\frac{y_k}{2^k}}.")+"",$r,In,Ja,Er,Fn,er,fa,tr=p("|\\psi\\rangle = \\displaystyle{ \\frac{1}{\\sqrt{N}} \\underbrace{ \\sum_{y_1=0}^1 \\ldots \\sum_{y_{n}=0}^1}_\\text{n terms} \\overbrace{e^{\\frac{2 \\pi i x y_1}{2^1}} |y_1\\rangle \\otimes \\ldots \\otimes e^{\\frac{2 \\pi i x y_n}{2^n}}|y_n\\rangle}^\\text{n terms} }")+"",Hr,ot,Qn,tt,Lr=p("k,")+"",ce,ma,nr=p("e^{\\frac{2 \\pi i x y_k}{2^k}}|y_k\\rangle")+"",no,qr,Xt,ar,rr,xr=p("e^{\\frac{2 \\pi i x \\cdot 0}{2^k}}|0\\rangle = 1 \\cdot |0\\rangle = |0\\rangle")+"",ao,sr,Ir=p("y_k = 0,")+"",ro,ds,bn,Fr,so=p("e^{\\frac{2 \\pi i x \\cdot 1}{2^k}}|1\\rangle = e^{\\frac{2 \\pi i x }{2^k}}|1\\rangle")+"",or,Qr,oo=p("y_k = 1,")+"",ka,Rr,ws,Ta,gn,vs,Rn,Jo=p("n")+"",bs,pa,io,gs,_a,lo,ys,Ma,ir,Ns,ca,uo,$s,Pa,Cr,lr,Br=p("|\\psi\\rangle = \\displaystyle{ \\frac{1}{\\sqrt{N}} \\sum_{y_1=0}^1 \\ldots \\sum_{y_{n}=0}^1 \\left( e^{\\frac{2 \\pi i x y_1}{2^1}} \\cdot \\ldots \\cdot e^{\\frac{2 \\pi i x y_n}{2^n}} \\right) \\left( |y_1\\rangle \\otimes \\ldots \\otimes |y_n\\rangle \\right)}")+"",Cs,ur,Cn,ei=p("|\\psi\\rangle = \\displaystyle{ = \\frac{1}{\\sqrt{N}} \\sum_{y_1=0}^1 \\ldots \\sum_{y_{n}=0}^1 \\prod_{k=1}^n e^{\\frac{2 \\pi i x y_k}{2^k}} \\left( |y_1\\rangle \\otimes \\ldots \\otimes |y_n\\rangle \\right)}")+"",kr,Bn,Es,Tr,it,hr,Dr=p("|\\psi\\rangle = \\displaystyle{ = \\frac{1}{\\sqrt{N}} \\sum_{y_1=0}^1 \\ldots \\sum_{y_{n}=0}^1 e^{\\sum_{k=1}^n \\frac{2 \\pi i x y_k}{2^k}} \\left( |y_1\\rangle \\otimes \\ldots \\otimes |y_n\\rangle \\right)}")+"",Bs,yn,fr,Wr,ho=p("2 \\pi i x")+"",mr,zr,fo=p("k,")+"",pr,Ds,Sa,Dn,mo=p("|\\psi\\rangle = \\displaystyle{ = \\frac{1}{\\sqrt{N}} \\sum_{y_1=0}^1 \\ldots \\sum_{y_{n}=0}^1 e^{2 \\pi i x \\sum_{k=1}^n \\frac{y_k}{2^k}} \\left( |y_1\\rangle \\otimes \\ldots \\otimes |y_n\\rangle \\right)}")+"",Mr,Ne,ks,Wn,ti=p("\\displaystyle{ \\sum_{k=1}^n \\frac{y_k}{2^k}}")+"",Ts,zn,ni=p("\\frac{y}{N}.")+"",Ms,jn,ai=p("y_k")+"",Ps,Yt,po=p("y")+"",_r,jr,_o=p("y.")+"",cr,Vr,Ws=p("|y\\rangle = |y_1\\rangle \\otimes \\ldots \\otimes |y_n\\rangle,")+"",bt,Ur,Vn,Gr,co=p("|\\psi\\rangle = \\displaystyle{ \\frac{1}{\\sqrt{N}} \\sum_{y=0}^{N - 1} e^{\\frac{2 \\pi i x y}{N}} |y\\rangle}")+"",Aa,Or,Ss,Ha,gt,As,Un,ri=p("x,")+"",Hs,La,wo=p("e^{\\frac{2 \\pi i x y}{N}}")+"",zs,$,se=p("y")+"",nt,qa,si=p("x,")+"",vo,Kr,oi=p("x")+"",Ke,js,bo,ko;return X=new Rt({props:{hovertext:_h,$$slots:{default:[dh]},$$scope:{ctx:e}}}),Ve=new Rt({props:{hovertext:ch,$$slots:{default:[wh]},$$scope:{ctx:e}}}),{c(){t=i("h2"),r=h("Quantum Fourier transform (QFT)"),s=S(),o=i("h2"),c=h("Representing numbers with qubits"),_=S(),m=i("p"),b=h("Consider "),v=i("span"),w=h(" qubits aranged in a row, each of which are in either of the two basis states "),E=i("span"),Q=h(" or "),K=i("span"),L=h(" With a little combinatorics, we can see that there are "),z=i("span"),H=h(" such combinations. For ease of notation, let "),I=i("span"),Y=S(),P=i("p"),re=h("For our purposes, we'll interpret these combinations as the "),Le(X.$$.fragment),D=h(" of the numbers from "),M=i("span"),ee=h(" to "),B=i("span"),U=h(" For example, let "),ie=i("span"),Ee=h(" and the qubits be in the following state: "),he=i("span"),T=h(' We can "read out" this state as the binary number '),J=i("span"),We=h(" which is equal to "),be=i("span"),ne=S(),ae=i("h2"),ye=h("QFT on the qubit level"),lt=S(),we=i("p"),fe=h("The "),Le(Ve.$$.fragment),ut=h(" is an operation that modifies the states of qubits in a particular way. (How this is done in practice is another topic, for now we'll only look at the mathematics.) Namely, if "),He=i("span"),st=h(" is the number represented by the qubits (in the example above, "),Ue=i("span"),G=h("), the QFT sets the state of the "),pe=i("span"),Lt=h("-th qubit to "),Ge=i("span"),qt=h(" In other words, it sets "),Oe=i("span"),kn=h(" and "),Je=i("span"),Tn=h(" for all "),et=i("span"),On=S(),Be=i("p"),en=h("Notice that even though "),tn=i("span"),an=h(" the associated measurement probabilities "),rn=i("span"),Pn=h(" for all "),sn=i("span"),on=h(" This is because the "),oe=i("span"),ln=h(" term - as we saw in the section about the Bloch-sphere - indicates the qubit's phase and does not affect measurement probabilities."),ya=S(),ge=i("p"),un=h("Just like the state of a single qubit can be the linear combination of "),Sn=i("span"),hn=h(" and "),An=i("span"),fn=h(" the state of these "),Dt=i("span"),mn=h(" qubits is essentially the linear combination of all the possible combinations of the "),Wt=i("span"),pn=h(" basis states - which, as we saw in the previous section, represent the integers from "),zt=i("span"),_n=h(" to "),Hn=i("span"),cn=h(" Take a moment to appreciate this fact. We applied an operator to "),jt=i("span"),dn=h(" qubits to obtain a quantum system that represents "),Vt=i("span"),wn=h(" numbers at the same time and is capable of performing computations on all of those numbers in parallel! This parallelism is one of the main properties that make quantum computers so powerful compared to classical ones. Since both basis states are measured with a probability of "),Ut=i("span"),xt=h(" for each qubit, any particular combination of the "),Et=i("span"),Ca=h(" basis states is measured with a probability of "),kt=i("span"),Ba=h(" What differs across these combinations - and is an essential component of the QFT - is the phase, as we'll see in the next section."),Ze=S(),Tt=i("h2"),Xn=h("QFT on the representation level"),Da=S(),ft=i("p"),Yn=h("Let's denote the state of the entire sequence of qubits with "),Jn=i("span"),ta=h(" and write it out as shown below:"),Wa=S(),Gt=i("p"),Xe=i("span"),It=S(),Ae=i("p"),Na=h("We can factor out the "),ct=i("span"),$a=h(" term to get:"),wt=S(),za=i("p"),vn=i("span"),Pr=S(),me=i("p"),Mt=h("Let "),ja=i("span"),Pt=h(" denote the binary number represented by the "),Va=i("span"),Kt=h(" qubits in a given basis state, and "),na=i("span"),ue=h(" the "),ze=i("span"),Ye=h("-th digit of "),Ln=i("span"),Fe=h(" In other words, "),ra=i("span"),us=h("\xA0if the "),sa=i("span"),hs=h("-th qubit is in the "),oa=i("span"),vt=h(" state, and "),ia=i("span"),fs=h("\xA0if it's in the "),la=i("span"),Ar=h(" state for all "),Ce=i("span"),ms=h(" Recalling our knowledge of binary numbers, we can write "),ua=i("span"),ps=h(" as the weighted sum of its digits: "),ha=i("span"),_s=h(" Notice that the "),qn=i("span"),cs=h(" term within the sum does not depend on "),xn=i("span"),Nr=h(" and so we can factor it out: "),Zt=i("span"),$r=h(" Remember this step, as it is going to be important shortly!"),In=S(),Ja=i("p"),Er=h("Using this new notation, we can write the state of the qubits in the form of a sum instead of a product:"),Fn=S(),er=i("p"),fa=i("span"),Hr=S(),ot=i("p"),Qn=h("In case you're wondering how the formula above can be derived from the definition we started with, note that for all "),tt=i("span"),ce=h(" the term "),ma=i("span"),no=h(" equals"),qr=S(),Xt=i("ul"),ar=i("li"),rr=i("span"),ao=h(" if "),sr=i("span"),ro=h(" and"),ds=S(),bn=i("li"),Fr=i("span"),or=h(" if "),Qr=i("span"),ka=S(),Rr=i("p"),ws=h("which is exactly how we defined the QFT."),Ta=S(),gn=i("p"),vs=h("The "),Rn=i("span"),bs=h(" embedded summations might seem confusing at first, but what they actually do is iterate over all possible combinations of basis states. In the final sum, these are included with "),pa=i("em"),io=h("equal weight"),gs=h(" (meaning they are measured with equal probability), but the composing basis states will have "),_a=i("em"),lo=h("different phases"),ys=h(" in each combination, as already mentioned at the end of the previous section."),Ma=S(),ir=i("p"),Ns=h("Let's now define the "),ca=i("em"),uo=h("phase of the combination"),$s=h(" as the product of the phases of individual qubits within that combination, and factor it out as shown below:"),Pa=S(),Cr=i("p"),lr=i("span"),Cs=S(),ur=i("p"),Cn=i("span"),kr=S(),Bn=i("p"),Es=h("After making use of the product rule for exponents..."),Tr=S(),it=i("p"),hr=i("span"),Bs=S(),yn=i("p"),fr=h("and factoring out the "),Wr=i("span"),mr=h(" term that does not depend on "),zr=i("span"),pr=h(" we arrive at the formula below:"),Ds=S(),Sa=i("p"),Dn=i("span"),Mr=S(),Ne=i("p"),ks=h("Recall what I asked you to keep in mind a few paragraphs ago, and notice that the sum in the exponential "),Wn=i("span"),Ts=h(" is actually equal to "),zn=i("span"),Ms=h(" Thus, we can now replace the individual "),jn=i("span"),Ps=h(" digits with the number "),Yt=i("span"),_r=h(" itself and the multiple, embedded summations with a single one that iterates over all possible values of "),jr=i("span"),cr=h(" In addition, let's abbreviate the notation we used for the product of the basis states with "),Vr=i("span"),bt=h(" to finally obtain this way more elegant formula for the QFT:"),Ur=S(),Vn=i("p"),Gr=i("span"),Aa=S(),Or=i("p"),Ss=h("The elegance comes from the fact that it shows what the qubits represent on a symbolic level, as opposed to the expression we started with that is a direct insight into the bit-level implementation."),Ha=S(),gt=i("p"),As=h("Now let's illustrate visually what the formula above actually means. To give a proper intuition, we'll look at multiple systems with increasing number of qubits. For a chosen value of "),Un=i("span"),Hs=h(" the plot below shows the "),La=i("span"),zs=h(" terms for all possible values of "),$=i("span"),nt=h(" that these systems can represent. Because this term is a complex number, the geometric representation of which would require two dimensions, the real and imaginary components are shown separately. Notice that as the number of qubits increases, the plots gradually turn into sinusoidal wave patterns. Furthermore, the number of peaks of these waves - their frequency - equals "),qa=i("span"),vo=h(" which you can verify by modifying "),Kr=i("span"),Ke=h(" with the help of the slider.")},l(g){t=l(g,"H2",{});var O=u(t);r=f(O,"Quantum Fourier transform (QFT)"),O.forEach(a),s=A(g),o=l(g,"H2",{});var Ls=u(o);c=f(Ls,"Representing numbers with qubits"),Ls.forEach(a),_=A(g),m=l(g,"P",{});var Ft=u(m);b=f(Ft,"Consider "),v=l(Ft,"SPAN",{});var ii=u(v);ii.forEach(a),w=f(Ft," qubits aranged in a row, each of which are in either of the two basis states "),E=l(Ft,"SPAN",{});var li=u(E);li.forEach(a),Q=f(Ft," or "),K=l(Ft,"SPAN",{});var at=u(K);at.forEach(a),L=f(Ft," With a little combinatorics, we can see that there are "),z=l(Ft,"SPAN",{});var ui=u(z);ui.forEach(a),H=f(Ft," such combinations. For ease of notation, let "),I=l(Ft,"SPAN",{});var hi=u(I);hi.forEach(a),Ft.forEach(a),Y=A(g),P=l(g,"P",{});var At=u(P);re=f(At,"For our purposes, we'll interpret these combinations as the "),qe(X.$$.fragment,At),D=f(At," of the numbers from "),M=l(At,"SPAN",{});var fi=u(M);fi.forEach(a),ee=f(At," to "),B=l(At,"SPAN",{});var mi=u(B);mi.forEach(a),U=f(At," For example, let "),ie=l(At,"SPAN",{});var pi=u(ie);pi.forEach(a),Ee=f(At," and the qubits be in the following state: "),he=l(At,"SPAN",{});var _i=u(he);_i.forEach(a),T=f(At,' We can "read out" this state as the binary number '),J=l(At,"SPAN",{});var ci=u(J);ci.forEach(a),We=f(At," which is equal to "),be=l(At,"SPAN",{});var di=u(be);di.forEach(a),At.forEach(a),ne=A(g),ae=l(g,"H2",{});var qs=u(ae);ye=f(qs,"QFT on the qubit level"),qs.forEach(a),lt=A(g),we=l(g,"P",{});var mt=u(we);fe=f(mt,"The "),qe(Ve.$$.fragment,mt),ut=f(mt," is an operation that modifies the states of qubits in a particular way. (How this is done in practice is another topic, for now we'll only look at the mathematics.) Namely, if "),He=l(mt,"SPAN",{});var To=u(He);To.forEach(a),st=f(mt," is the number represented by the qubits (in the example above, "),Ue=l(mt,"SPAN",{});var Mo=u(Ue);Mo.forEach(a),G=f(mt,"), the QFT sets the state of the "),pe=l(mt,"SPAN",{});var dr=u(pe);dr.forEach(a),Lt=f(mt,"-th qubit to "),Ge=l(mt,"SPAN",{});var wi=u(Ge);wi.forEach(a),qt=f(mt," In other words, it sets "),Oe=l(mt,"SPAN",{});var vi=u(Oe);vi.forEach(a),kn=f(mt," and "),Je=l(mt,"SPAN",{});var bi=u(Je);bi.forEach(a),Tn=f(mt," for all "),et=l(mt,"SPAN",{});var xa=u(et);xa.forEach(a),mt.forEach(a),On=A(g),Be=l(g,"P",{});var da=u(Be);en=f(da,"Notice that even though "),tn=l(da,"SPAN",{});var gi=u(tn);gi.forEach(a),an=f(da," the associated measurement probabilities "),rn=l(da,"SPAN",{});var yi=u(rn);yi.forEach(a),Pn=f(da," for all "),sn=l(da,"SPAN",{});var Ni=u(sn);Ni.forEach(a),on=f(da," This is because the "),oe=l(da,"SPAN",{});var Po=u(oe);Po.forEach(a),ln=f(da," term - as we saw in the section about the Bloch-sphere - indicates the qubit's phase and does not affect measurement probabilities."),da.forEach(a),ya=A(g),ge=l(g,"P",{});var Me=u(ge);un=f(Me,"Just like the state of a single qubit can be the linear combination of "),Sn=l(Me,"SPAN",{});var $i=u(Sn);$i.forEach(a),hn=f(Me," and "),An=l(Me,"SPAN",{});var Ei=u(An);Ei.forEach(a),fn=f(Me," the state of these "),Dt=l(Me,"SPAN",{});var ki=u(Dt);ki.forEach(a),mn=f(Me," qubits is essentially the linear combination of all the possible combinations of the "),Wt=l(Me,"SPAN",{});var Ti=u(Wt);Ti.forEach(a),pn=f(Me," basis states - which, as we saw in the previous section, represent the integers from "),zt=l(Me,"SPAN",{});var Ht=u(zt);Ht.forEach(a),_n=f(Me," to "),Hn=l(Me,"SPAN",{});var Mi=u(Hn);Mi.forEach(a),cn=f(Me," Take a moment to appreciate this fact. We applied an operator to "),jt=l(Me,"SPAN",{});var Pi=u(jt);Pi.forEach(a),dn=f(Me," qubits to obtain a quantum system that represents "),Vt=l(Me,"SPAN",{});var Si=u(Vt);Si.forEach(a),wn=f(Me," numbers at the same time and is capable of performing computations on all of those numbers in parallel! This parallelism is one of the main properties that make quantum computers so powerful compared to classical ones. Since both basis states are measured with a probability of "),Ut=l(Me,"SPAN",{});var Ai=u(Ut);Ai.forEach(a),xt=f(Me," for each qubit, any particular combination of the "),Et=l(Me,"SPAN",{});var Hi=u(Et);Hi.forEach(a),Ca=f(Me," basis states is measured with a probability of "),kt=l(Me,"SPAN",{});var Li=u(kt);Li.forEach(a),Ba=f(Me," What differs across these combinations - and is an essential component of the QFT - is the phase, as we'll see in the next section."),Me.forEach(a),Ze=A(g),Tt=l(g,"H2",{});var So=u(Tt);Xn=f(So,"QFT on the representation level"),So.forEach(a),Da=A(g),ft=l(g,"P",{});var xs=u(ft);Yn=f(xs,"Let's denote the state of the entire sequence of qubits with "),Jn=l(xs,"SPAN",{});var rt=u(Jn);rt.forEach(a),ta=f(xs," and write it out as shown below:"),xs.forEach(a),Wa=A(g),Gt=l(g,"P",{});var Ao=u(Gt);Xe=l(Ao,"SPAN",{});var qi=u(Xe);qi.forEach(a),Ao.forEach(a),It=A(g),Ae=l(g,"P",{});var Vs=u(Ae);Na=f(Vs,"We can factor out the "),ct=l(Vs,"SPAN",{});var xi=u(ct);xi.forEach(a),$a=f(Vs," term to get:"),Vs.forEach(a),wt=A(g),za=l(g,"P",{});var Ho=u(za);vn=l(Ho,"SPAN",{});var Ii=u(vn);Ii.forEach(a),Ho.forEach(a),Pr=A(g),me=l(g,"P",{});var $e=u(me);Mt=f($e,"Let "),ja=l($e,"SPAN",{});var Fi=u(ja);Fi.forEach(a),Pt=f($e," denote the binary number represented by the "),Va=l($e,"SPAN",{});var Qi=u(Va);Qi.forEach(a),Kt=f($e," qubits in a given basis state, and "),na=l($e,"SPAN",{});var Ia=u(na);Ia.forEach(a),ue=f($e," the "),ze=l($e,"SPAN",{});var Ri=u(ze);Ri.forEach(a),Ye=f($e,"-th digit of "),Ln=l($e,"SPAN",{});var Ci=u(Ln);Ci.forEach(a),Fe=f($e," In other words, "),ra=l($e,"SPAN",{});var Bi=u(ra);Bi.forEach(a),us=f($e,"\xA0if the "),sa=l($e,"SPAN",{});var Di=u(sa);Di.forEach(a),hs=f($e,"-th qubit is in the "),oa=l($e,"SPAN",{});var Lo=u(oa);Lo.forEach(a),vt=f($e," state, and "),ia=l($e,"SPAN",{});var Te=u(ia);Te.forEach(a),fs=f($e,"\xA0if it's in the "),la=l($e,"SPAN",{});var Wi=u(la);Wi.forEach(a),Ar=f($e," state for all "),Ce=l($e,"SPAN",{});var zi=u(Ce);zi.forEach(a),ms=f($e," Recalling our knowledge of binary numbers, we can write "),ua=l($e,"SPAN",{});var ji=u(ua);ji.forEach(a),ps=f($e," as the weighted sum of its digits: "),ha=l($e,"SPAN",{});var Vi=u(ha);Vi.forEach(a),_s=f($e," Notice that the "),qn=l($e,"SPAN",{});var Ui=u(qn);Ui.forEach(a),cs=f($e," term within the sum does not depend on "),xn=l($e,"SPAN",{});var Gi=u(xn);Gi.forEach(a),Nr=f($e," and so we can factor it out: "),Zt=l($e,"SPAN",{});var Oi=u(Zt);Oi.forEach(a),$r=f($e," Remember this step, as it is going to be important shortly!"),$e.forEach(a),In=A(g),Ja=l(g,"P",{});var qo=u(Ja);Er=f(qo,"Using this new notation, we can write the state of the qubits in the form of a sum instead of a product:"),qo.forEach(a),Fn=A(g),er=l(g,"P",{});var xo=u(er);fa=l(xo,"SPAN",{});var Ki=u(fa);Ki.forEach(a),xo.forEach(a),Hr=A(g),ot=l(g,"P",{});var Zr=u(ot);Qn=f(Zr,"In case you're wondering how the formula above can be derived from the definition we started with, note that for all "),tt=l(Zr,"SPAN",{});var Zi=u(tt);Zi.forEach(a),ce=f(Zr," the term "),ma=l(Zr,"SPAN",{});var Xi=u(ma);Xi.forEach(a),no=f(Zr," equals"),Zr.forEach(a),qr=A(g),Xt=l(g,"UL",{});var Us=u(Xt);ar=l(Us,"LI",{});var Is=u(ar);rr=l(Is,"SPAN",{});var Yi=u(rr);Yi.forEach(a),ao=f(Is," if "),sr=l(Is,"SPAN",{});var Io=u(sr);Io.forEach(a),ro=f(Is," and"),Is.forEach(a),ds=A(Us),bn=l(Us,"LI",{});var Nn=u(bn);Fr=l(Nn,"SPAN",{});var Ji=u(Fr);Ji.forEach(a),or=f(Nn," if "),Qr=l(Nn,"SPAN",{});var el=u(Qr);el.forEach(a),Nn.forEach(a),Us.forEach(a),ka=A(g),Rr=l(g,"P",{});var Fo=u(Rr);ws=f(Fo,"which is exactly how we defined the QFT."),Fo.forEach(a),Ta=A(g),gn=l(g,"P",{});var wr=u(gn);vs=f(wr,"The "),Rn=l(wr,"SPAN",{});var Qo=u(Rn);Qo.forEach(a),bs=f(wr," embedded summations might seem confusing at first, but what they actually do is iterate over all possible combinations of basis states. In the final sum, these are included with "),pa=l(wr,"EM",{});var Qt=u(pa);io=f(Qt,"equal weight"),Qt.forEach(a),gs=f(wr," (meaning they are measured with equal probability), but the composing basis states will have "),_a=l(wr,"EM",{});var Ro=u(_a);lo=f(Ro,"different phases"),Ro.forEach(a),ys=f(wr," in each combination, as already mentioned at the end of the previous section."),wr.forEach(a),Ma=A(g),ir=l(g,"P",{});var Gs=u(ir);Ns=f(Gs,"Let's now define the "),ca=l(Gs,"EM",{});var Co=u(ca);uo=f(Co,"phase of the combination"),Co.forEach(a),$s=f(Gs," as the product of the phases of individual qubits within that combination, and factor it out as shown below:"),Gs.forEach(a),Pa=A(g),Cr=l(g,"P",{});var Bo=u(Cr);lr=l(Bo,"SPAN",{});var tl=u(lr);tl.forEach(a),Bo.forEach(a),Cs=A(g),ur=l(g,"P",{});var Gn=u(ur);Cn=l(Gn,"SPAN",{});var nl=u(Cn);nl.forEach(a),Gn.forEach(a),kr=A(g),Bn=l(g,"P",{});var Do=u(Bn);Es=f(Do,"After making use of the product rule for exponents..."),Do.forEach(a),Tr=A(g),it=l(g,"P",{});var Wo=u(it);hr=l(Wo,"SPAN",{});var al=u(hr);al.forEach(a),Wo.forEach(a),Bs=A(g),yn=l(g,"P",{});var Os=u(yn);fr=f(Os,"and factoring out the "),Wr=l(Os,"SPAN",{});var iu=u(Wr);iu.forEach(a),mr=f(Os," term that does not depend on "),zr=l(Os,"SPAN",{});var lu=u(zr);lu.forEach(a),pr=f(Os," we arrive at the formula below:"),Os.forEach(a),Ds=A(g),Sa=l(g,"P",{});var Nl=u(Sa);Dn=l(Nl,"SPAN",{});var uu=u(Dn);uu.forEach(a),Nl.forEach(a),Mr=A(g),Ne=l(g,"P",{});var $n=u(Ne);ks=f($n,"Recall what I asked you to keep in mind a few paragraphs ago, and notice that the sum in the exponential "),Wn=l($n,"SPAN",{});var hu=u(Wn);hu.forEach(a),Ts=f($n," is actually equal to "),zn=l($n,"SPAN",{});var fu=u(zn);fu.forEach(a),Ms=f($n," Thus, we can now replace the individual "),jn=l($n,"SPAN",{});var mu=u(jn);mu.forEach(a),Ps=f($n," digits with the number "),Yt=l($n,"SPAN",{});var pu=u(Yt);pu.forEach(a),_r=f($n," itself and the multiple, embedded summations with a single one that iterates over all possible values of "),jr=l($n,"SPAN",{});var _u=u(jr);_u.forEach(a),cr=f($n," In addition, let's abbreviate the notation we used for the product of the basis states with "),Vr=l($n,"SPAN",{});var cu=u(Vr);cu.forEach(a),bt=f($n," to finally obtain this way more elegant formula for the QFT:"),$n.forEach(a),Ur=A(g),Vn=l(g,"P",{});var $l=u(Vn);Gr=l($l,"SPAN",{});var du=u(Gr);du.forEach(a),$l.forEach(a),Aa=A(g),Or=l(g,"P",{});var El=u(Or);Ss=f(El,"The elegance comes from the fact that it shows what the qubits represent on a symbolic level, as opposed to the expression we started with that is a direct insight into the bit-level implementation."),El.forEach(a),Ha=A(g),gt=l(g,"P",{});var wa=u(gt);As=f(wa,"Now let's illustrate visually what the formula above actually means. To give a proper intuition, we'll look at multiple systems with increasing number of qubits. For a chosen value of "),Un=l(wa,"SPAN",{});var wu=u(Un);wu.forEach(a),Hs=f(wa," the plot below shows the "),La=l(wa,"SPAN",{});var vu=u(La);vu.forEach(a),zs=f(wa," terms for all possible values of "),$=l(wa,"SPAN",{});var bu=u($);bu.forEach(a),nt=f(wa," that these systems can represent. Because this term is a complex number, the geometric representation of which would require two dimensions, the real and imaginary components are shown separately. Notice that as the number of qubits increases, the plots gradually turn into sinusoidal wave patterns. Furthermore, the number of peaks of these waves - their frequency - equals "),qa=l(wa,"SPAN",{});var gu=u(qa);gu.forEach(a),vo=f(wa," which you can verify by modifying "),Kr=l(wa,"SPAN",{});var yu=u(Kr);yu.forEach(a),Ke=f(wa," with the help of the slider."),wa.forEach(a)},m(g,O){y(g,t,O),n(t,r),y(g,s,O),y(g,o,O),n(o,c),y(g,_,O),y(g,m,O),n(m,b),n(m,v),v.innerHTML=k,n(m,w),n(m,E),E.innerHTML=N,n(m,Q),n(m,K),K.innerHTML=V,n(m,L),n(m,z),z.innerHTML=x,n(m,H),n(m,I),I.innerHTML=j,y(g,Y,O),y(g,P,O),n(P,re),xe(X,P,null),n(P,D),n(P,M),M.innerHTML=q,n(P,ee),n(P,B),B.innerHTML=R,n(P,U),n(P,ie),ie.innerHTML=te,n(P,Ee),n(P,he),he.innerHTML=Z,n(P,T),n(P,J),J.innerHTML=de,n(P,We),n(P,be),be.innerHTML=je,y(g,ne,O),y(g,ae,O),n(ae,ye),y(g,lt,O),y(g,we,O),n(we,fe),xe(Ve,we,null),n(we,ut),n(we,He),He.innerHTML=ke,n(we,st),n(we,Ue),Ue.innerHTML=yt,n(we,G),n(we,pe),pe.innerHTML=le,n(we,Lt),n(we,Ge),Ge.innerHTML=Nt,n(we,qt),n(we,Oe),Oe.innerHTML=$t,n(we,kn),n(we,Je),Je.innerHTML=Jt,n(we,Tn),n(we,et),et.innerHTML=pt,y(g,On,O),y(g,Be,O),n(Be,en),n(Be,tn),tn.innerHTML=nn,n(Be,an),n(Be,rn),rn.innerHTML=Mn,n(Be,Pn),n(Be,sn),sn.innerHTML=Bt,n(Be,on),n(Be,oe),oe.innerHTML=ts,n(Be,ln),y(g,ya,O),y(g,ge,O),n(ge,un),n(ge,Sn),Sn.innerHTML=Kn,n(ge,hn),n(ge,An),An.innerHTML=_t,n(ge,fn),n(ge,Dt),Dt.innerHTML=ns,n(ge,mn),n(ge,Wt),Wt.innerHTML=as,n(ge,pn),n(ge,zt),zt.innerHTML=rs,n(ge,_n),n(ge,Hn),Hn.innerHTML=ht,n(ge,cn),n(ge,jt),jt.innerHTML=ss,n(ge,dn),n(ge,Vt),Vt.innerHTML=os,n(ge,wn),n(ge,Ut),Ut.innerHTML=is,n(ge,xt),n(ge,Et),Et.innerHTML=Ra,n(ge,Ca),n(ge,kt),kt.innerHTML=Zn,n(ge,Ba),y(g,Ze,O),y(g,Tt,O),n(Tt,Xn),y(g,Da,O),y(g,ft,O),n(ft,Yn),n(ft,Jn),Jn.innerHTML=ea,n(ft,ta),y(g,Wa,O),y(g,Gt,O),n(Gt,Xe),Xe.innerHTML=ls,y(g,It,O),y(g,Ae,O),n(Ae,Na),n(Ae,ct),ct.innerHTML=dt,n(Ae,$a),y(g,wt,O),y(g,za,O),n(za,vn),vn.innerHTML=Ot,y(g,Pr,O),y(g,me,O),n(me,Mt),n(me,ja),ja.innerHTML=gr,n(me,Pt),n(me,Va),Va.innerHTML=yr,n(me,Kt),n(me,na),na.innerHTML=Sr,n(me,ue),n(me,ze),ze.innerHTML=aa,n(me,Ye),n(me,Ln),Ln.innerHTML=De,n(me,Fe),n(me,ra),ra.innerHTML=Ua,n(me,us),n(me,sa),sa.innerHTML=Ga,n(me,hs),n(me,oa),oa.innerHTML=Ea,n(me,vt),n(me,ia),ia.innerHTML=Oa,n(me,fs),n(me,la),la.innerHTML=Ka,n(me,Ar),n(me,Ce),Ce.innerHTML=Za,n(me,ms),n(me,ua),ua.innerHTML=Xa,n(me,ps),n(me,ha),ha.innerHTML=Ya,n(me,_s),n(me,qn),qn.innerHTML=_e,n(me,cs),n(me,xn),xn.innerHTML=St,n(me,Nr),n(me,Zt),Zt.innerHTML=to,n(me,$r),y(g,In,O),y(g,Ja,O),n(Ja,Er),y(g,Fn,O),y(g,er,O),n(er,fa),fa.innerHTML=tr,y(g,Hr,O),y(g,ot,O),n(ot,Qn),n(ot,tt),tt.innerHTML=Lr,n(ot,ce),n(ot,ma),ma.innerHTML=nr,n(ot,no),y(g,qr,O),y(g,Xt,O),n(Xt,ar),n(ar,rr),rr.innerHTML=xr,n(ar,ao),n(ar,sr),sr.innerHTML=Ir,n(ar,ro),n(Xt,ds),n(Xt,bn),n(bn,Fr),Fr.innerHTML=so,n(bn,or),n(bn,Qr),Qr.innerHTML=oo,y(g,ka,O),y(g,Rr,O),n(Rr,ws),y(g,Ta,O),y(g,gn,O),n(gn,vs),n(gn,Rn),Rn.innerHTML=Jo,n(gn,bs),n(gn,pa),n(pa,io),n(gn,gs),n(gn,_a),n(_a,lo),n(gn,ys),y(g,Ma,O),y(g,ir,O),n(ir,Ns),n(ir,ca),n(ca,uo),n(ir,$s),y(g,Pa,O),y(g,Cr,O),n(Cr,lr),lr.innerHTML=Br,y(g,Cs,O),y(g,ur,O),n(ur,Cn),Cn.innerHTML=ei,y(g,kr,O),y(g,Bn,O),n(Bn,Es),y(g,Tr,O),y(g,it,O),n(it,hr),hr.innerHTML=Dr,y(g,Bs,O),y(g,yn,O),n(yn,fr),n(yn,Wr),Wr.innerHTML=ho,n(yn,mr),n(yn,zr),zr.innerHTML=fo,n(yn,pr),y(g,Ds,O),y(g,Sa,O),n(Sa,Dn),Dn.innerHTML=mo,y(g,Mr,O),y(g,Ne,O),n(Ne,ks),n(Ne,Wn),Wn.innerHTML=ti,n(Ne,Ts),n(Ne,zn),zn.innerHTML=ni,n(Ne,Ms),n(Ne,jn),jn.innerHTML=ai,n(Ne,Ps),n(Ne,Yt),Yt.innerHTML=po,n(Ne,_r),n(Ne,jr),jr.innerHTML=_o,n(Ne,cr),n(Ne,Vr),Vr.innerHTML=Ws,n(Ne,bt),y(g,Ur,O),y(g,Vn,O),n(Vn,Gr),Gr.innerHTML=co,y(g,Aa,O),y(g,Or,O),n(Or,Ss),y(g,Ha,O),y(g,gt,O),n(gt,As),n(gt,Un),Un.innerHTML=ri,n(gt,Hs),n(gt,La),La.innerHTML=wo,n(gt,zs),n(gt,$),$.innerHTML=se,n(gt,nt),n(gt,qa),qa.innerHTML=si,n(gt,vo),n(gt,Kr),Kr.innerHTML=oi,n(gt,Ke),js=!0,bo||(ko=[d(v,"mouseenter",e[0]),d(E,"mouseenter",e[1]),d(K,"mouseenter",e[2]),d(z,"mouseenter",e[3]),d(I,"mouseenter",e[4]),d(M,"mouseenter",e[5]),d(B,"mouseenter",e[6]),d(ie,"mouseenter",e[7]),d(he,"mouseenter",e[8]),d(J,"mouseenter",e[9]),d(be,"mouseenter",e[10]),d(He,"mouseenter",e[11]),d(Ue,"mouseenter",e[12]),d(pe,"mouseenter",e[13]),d(Ge,"mouseenter",e[14]),d(Oe,"mouseenter",e[15]),d(Je,"mouseenter",e[16]),d(et,"mouseenter",e[17]),d(tn,"mouseenter",e[18]),d(rn,"mouseenter",e[19]),d(sn,"mouseenter",e[20]),d(oe,"mouseenter",e[21]),d(Sn,"mouseenter",e[22]),d(An,"mouseenter",e[23]),d(Dt,"mouseenter",e[24]),d(Wt,"mouseenter",e[25]),d(zt,"mouseenter",e[26]),d(Hn,"mouseenter",e[27]),d(jt,"mouseenter",e[28]),d(Vt,"mouseenter",e[29]),d(Ut,"mouseenter",e[30]),d(Et,"mouseenter",e[31]),d(kt,"mouseenter",e[32]),d(Jn,"mouseenter",e[33]),d(Xe,"mouseenter",e[34]),d(ct,"mouseenter",e[35]),d(vn,"mouseenter",e[36]),d(ja,"mouseenter",e[37]),d(Va,"mouseenter",e[38]),d(na,"mouseenter",e[39]),d(ze,"mouseenter",e[40]),d(Ln,"mouseenter",e[41]),d(ra,"mouseenter",e[42]),d(sa,"mouseenter",e[43]),d(oa,"mouseenter",e[44]),d(ia,"mouseenter",e[45]),d(la,"mouseenter",e[46]),d(Ce,"mouseenter",e[47]),d(ua,"mouseenter",e[48]),d(ha,"mouseenter",e[49]),d(qn,"mouseenter",e[50]),d(xn,"mouseenter",e[51]),d(Zt,"mouseenter",e[52]),d(fa,"mouseenter",e[53]),d(tt,"mouseenter",e[54]),d(ma,"mouseenter",e[55]),d(rr,"mouseenter",e[56]),d(sr,"mouseenter",e[57]),d(Fr,"mouseenter",e[58]),d(Qr,"mouseenter",e[59]),d(Rn,"mouseenter",e[60]),d(lr,"mouseenter",e[61]),d(Cn,"mouseenter",e[62]),d(hr,"mouseenter",e[63]),d(Wr,"mouseenter",e[64]),d(zr,"mouseenter",e[65]),d(Dn,"mouseenter",e[66]),d(Wn,"mouseenter",e[67]),d(zn,"mouseenter",e[68]),d(jn,"mouseenter",e[69]),d(Yt,"mouseenter",e[70]),d(jr,"mouseenter",e[71]),d(Vr,"mouseenter",e[72]),d(Gr,"mouseenter",e[73]),d(Un,"mouseenter",e[74]),d(La,"mouseenter",e[75]),d($,"mouseenter",e[76]),d(qa,"mouseenter",e[77]),d(Kr,"mouseenter",e[78])],bo=!0)},p(g,O){const Ls={};O[2]&131072&&(Ls.$$scope={dirty:O,ctx:g}),X.$set(Ls);const Ft={};O[2]&131072&&(Ft.$$scope={dirty:O,ctx:g}),Ve.$set(Ft)},i(g){js||(Pe(X.$$.fragment,g),Pe(Ve.$$.fragment,g),js=!0)},o(g){Se(X.$$.fragment,g),Se(Ve.$$.fragment,g),js=!1},d(g){g&&a(t),g&&a(s),g&&a(o),g&&a(_),g&&a(m),g&&a(Y),g&&a(P),Ie(X),g&&a(ne),g&&a(ae),g&&a(lt),g&&a(we),Ie(Ve),g&&a(On),g&&a(Be),g&&a(ya),g&&a(ge),g&&a(Ze),g&&a(Tt),g&&a(Da),g&&a(ft),g&&a(Wa),g&&a(Gt),g&&a(It),g&&a(Ae),g&&a(wt),g&&a(za),g&&a(Pr),g&&a(me),g&&a(In),g&&a(Ja),g&&a(Fn),g&&a(er),g&&a(Hr),g&&a(ot),g&&a(qr),g&&a(Xt),g&&a(ka),g&&a(Rr),g&&a(Ta),g&&a(gn),g&&a(Ma),g&&a(ir),g&&a(Pa),g&&a(Cr),g&&a(Cs),g&&a(ur),g&&a(kr),g&&a(Bn),g&&a(Tr),g&&a(it),g&&a(Bs),g&&a(yn),g&&a(Ds),g&&a(Sa),g&&a(Mr),g&&a(Ne),g&&a(Ur),g&&a(Vn),g&&a(Aa),g&&a(Or),g&&a(Ha),g&&a(gt),bo=!1,es(ko)}}}function W(e){console.log(e)}function bh(e){return[()=>W(["n"]),()=>W([]),()=>W([]),()=>W(["m","n","t","s"]),()=>W(["N","n"]),()=>W([]),()=>W(["N"]),()=>W(["n"]),()=>W([]),()=>W([]),()=>W([]),()=>W(["x"]),()=>W(["x"]),()=>W(["k"]),()=>W(["x","k"]),()=>W(["k","\\alpha"]),()=>W(["x","k","\\beta"]),()=>W(["n","k"]),()=>W(["k","\\alpha","\\beta"]),()=>W(["k","\\alpha","\\beta"]),()=>W(["n","k"]),()=>W(["x","k"]),()=>W([]),()=>W([]),()=>W(["n"]),()=>W(["n"]),()=>W([]),()=>W(["N"]),()=>W(["n"]),()=>W(["n"]),()=>W([]),()=>W(["n"]),()=>W(["m","t","s","N","r","n"]),()=>W(["\\psi"]),()=>W(["m","t","x","s","\\psi","r","n"]),()=>W([]),()=>W(["x","N","\\psi","n"]),()=>W(["y"]),()=>W(["n"]),()=>W(["k","y"]),()=>W(["k"]),()=>W(["y"]),()=>W(["k","y"]),()=>W(["k"]),()=>W([]),()=>W(["k","y"]),()=>W([]),()=>W(["n","k"]),()=>W(["y"]),()=>W(["k","y","n"]),()=>W(["n"]),()=>W(["k"]),()=>W(["k","N","n","y"]),()=>W(["m","y","t","x","s","N","\\psi","r","n"]),()=>W(["k"]),()=>W(["x","k","y"]),()=>W(["x","k"]),()=>W(["k","y"]),()=>W(["x","k"]),()=>W(["k","y"]),()=>W(["n"]),()=>W(["y","x","N","\\psi","n"]),()=>W(["y","k","x","N","\\psi","n"]),()=>W(["y","k","x","N","\\psi","n"]),()=>W(["x"]),()=>W(["k"]),()=>W(["y","k","x","N","\\psi","n"]),()=>W(["y","n","k"]),()=>W(["N","y"]),()=>W(["k","y"]),()=>W(["y"]),()=>W(["y"]),()=>W(["n","y"]),()=>W(["x","N","\\psi","y"]),()=>W(["x"]),()=>W(["x","N","y"]),()=>W(["y"]),()=>W(["x"]),()=>W(["x"])]}class gh extends va{constructor(t){super(),ba(this,t,bh,vh,ga,{},null,[-1,-1,-1])}}function Go(e,t){return e==null||t==null?NaN:e<t?-1:e>t?1:e>=t?0:NaN}function yh(e,t){return e==null||t==null?NaN:t<e?-1:t>e?1:t>=e?0:NaN}function Xl(e){let t,r,s;e.length!==2?(t=Go,r=(m,b)=>Go(e(m),b),s=(m,b)=>e(m)-b):(t=e===Go||e===yh?e:Nh,r=e,s=e);function o(m,b,v=0,k=m.length){if(v<k){if(t(b,b)!==0)return k;do{const w=v+k>>>1;r(m[w],b)<0?v=w+1:k=w}while(v<k)}return v}function c(m,b,v=0,k=m.length){if(v<k){if(t(b,b)!==0)return k;do{const w=v+k>>>1;r(m[w],b)<=0?v=w+1:k=w}while(v<k)}return v}function _(m,b,v=0,k=m.length){const w=o(m,b,v,k-1);return w>v&&s(m[w-1],b)>-s(m[w],b)?w-1:w}return{left:o,center:_,right:c}}function Nh(){return 0}function $h(e){return e===null?NaN:+e}const Eh=Xl(Go),kh=Eh.right;Xl($h).center;const Th=kh;function Sl(e,t){let r,s;if(t===void 0)for(const o of e)o!=null&&(r===void 0?o>=o&&(r=s=o):(r>o&&(r=o),s<o&&(s=o)));else{let o=-1;for(let c of e)(c=t(c,++o,e))!=null&&(r===void 0?c>=c&&(r=s=c):(r>c&&(r=c),s<c&&(s=c)))}return[r,s]}var il=Math.sqrt(50),ll=Math.sqrt(10),ul=Math.sqrt(2);function Mh(e,t,r){var s,o=-1,c,_,m;if(t=+t,e=+e,r=+r,e===t&&r>0)return[e];if((s=t<e)&&(c=e,e=t,t=c),(m=Yl(e,t,r))===0||!isFinite(m))return[];if(m>0){let b=Math.round(e/m),v=Math.round(t/m);for(b*m<e&&++b,v*m>t&&--v,_=new Array(c=v-b+1);++o<c;)_[o]=(b+o)*m}else{m=-m;let b=Math.round(e*m),v=Math.round(t*m);for(b/m<e&&++b,v/m>t&&--v,_=new Array(c=v-b+1);++o<c;)_[o]=(b+o)/m}return s&&_.reverse(),_}function Yl(e,t,r){var s=(t-e)/Math.max(0,r),o=Math.floor(Math.log(s)/Math.LN10),c=s/Math.pow(10,o);return o>=0?(c>=il?10:c>=ll?5:c>=ul?2:1)*Math.pow(10,o):-Math.pow(10,-o)/(c>=il?10:c>=ll?5:c>=ul?2:1)}function Ph(e,t,r){var s=Math.abs(t-e)/Math.max(0,r),o=Math.pow(10,Math.floor(Math.log(s)/Math.LN10)),c=s/o;return c>=il?o*=10:c>=ll?o*=5:c>=ul&&(o*=2),t<e?-o:o}function Sh(e,t){switch(arguments.length){case 0:break;case 1:this.range(e);break;default:this.range(t).domain(e);break}return this}function vl(e,t,r){e.prototype=t.prototype=r,r.constructor=e}function Jl(e,t){var r=Object.create(e.prototype);for(var s in t)r[s]=t[s];return r}function Eo(){}var yo=.7,Oo=1/yo,Ys="\\s*([+-]?\\d+)\\s*",No="\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",br="\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",Ah=/^#([0-9a-f]{3,8})$/,Hh=new RegExp(`^rgb\\(${Ys},${Ys},${Ys}\\)$`),Lh=new RegExp(`^rgb\\(${br},${br},${br}\\)$`),qh=new RegExp(`^rgba\\(${Ys},${Ys},${Ys},${No}\\)$`),xh=new RegExp(`^rgba\\(${br},${br},${br},${No}\\)$`),Ih=new RegExp(`^hsl\\(${No},${br},${br}\\)$`),Fh=new RegExp(`^hsla\\(${No},${br},${br},${No}\\)$`),Al={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074};vl(Eo,$o,{copy(e){return Object.assign(new this.constructor,this,e)},displayable(){return this.rgb().displayable()},hex:Hl,formatHex:Hl,formatHex8:Qh,formatHsl:Rh,formatRgb:Ll,toString:Ll});function Hl(){return this.rgb().formatHex()}function Qh(){return this.rgb().formatHex8()}function Rh(){return eu(this).formatHsl()}function Ll(){return this.rgb().formatRgb()}function $o(e){var t,r;return e=(e+"").trim().toLowerCase(),(t=Ah.exec(e))?(r=t[1].length,t=parseInt(t[1],16),r===6?ql(t):r===3?new En(t>>8&15|t>>4&240,t>>4&15|t&240,(t&15)<<4|t&15,1):r===8?jo(t>>24&255,t>>16&255,t>>8&255,(t&255)/255):r===4?jo(t>>12&15|t>>8&240,t>>8&15|t>>4&240,t>>4&15|t&240,((t&15)<<4|t&15)/255):null):(t=Hh.exec(e))?new En(t[1],t[2],t[3],1):(t=Lh.exec(e))?new En(t[1]*255/100,t[2]*255/100,t[3]*255/100,1):(t=qh.exec(e))?jo(t[1],t[2],t[3],t[4]):(t=xh.exec(e))?jo(t[1]*255/100,t[2]*255/100,t[3]*255/100,t[4]):(t=Ih.exec(e))?Fl(t[1],t[2]/100,t[3]/100,1):(t=Fh.exec(e))?Fl(t[1],t[2]/100,t[3]/100,t[4]):Al.hasOwnProperty(e)?ql(Al[e]):e==="transparent"?new En(NaN,NaN,NaN,0):null}function ql(e){return new En(e>>16&255,e>>8&255,e&255,1)}function jo(e,t,r,s){return s<=0&&(e=t=r=NaN),new En(e,t,r,s)}function Ch(e){return e instanceof Eo||(e=$o(e)),e?(e=e.rgb(),new En(e.r,e.g,e.b,e.opacity)):new En}function hl(e,t,r,s){return arguments.length===1?Ch(e):new En(e,t,r,s==null?1:s)}function En(e,t,r,s){this.r=+e,this.g=+t,this.b=+r,this.opacity=+s}vl(En,hl,Jl(Eo,{brighter(e){return e=e==null?Oo:Math.pow(Oo,e),new En(this.r*e,this.g*e,this.b*e,this.opacity)},darker(e){return e=e==null?yo:Math.pow(yo,e),new En(this.r*e,this.g*e,this.b*e,this.opacity)},rgb(){return this},clamp(){return new En(Rs(this.r),Rs(this.g),Rs(this.b),Ko(this.opacity))},displayable(){return-.5<=this.r&&this.r<255.5&&-.5<=this.g&&this.g<255.5&&-.5<=this.b&&this.b<255.5&&0<=this.opacity&&this.opacity<=1},hex:xl,formatHex:xl,formatHex8:Bh,formatRgb:Il,toString:Il}));function xl(){return`#${Qs(this.r)}${Qs(this.g)}${Qs(this.b)}`}function Bh(){return`#${Qs(this.r)}${Qs(this.g)}${Qs(this.b)}${Qs((isNaN(this.opacity)?1:this.opacity)*255)}`}function Il(){const e=Ko(this.opacity);return`${e===1?"rgb(":"rgba("}${Rs(this.r)}, ${Rs(this.g)}, ${Rs(this.b)}${e===1?")":`, ${e})`}`}function Ko(e){return isNaN(e)?1:Math.max(0,Math.min(1,e))}function Rs(e){return Math.max(0,Math.min(255,Math.round(e)||0))}function Qs(e){return e=Rs(e),(e<16?"0":"")+e.toString(16)}function Fl(e,t,r,s){return s<=0?e=t=r=NaN:r<=0||r>=1?e=t=NaN:t<=0&&(e=NaN),new Qa(e,t,r,s)}function eu(e){if(e instanceof Qa)return new Qa(e.h,e.s,e.l,e.opacity);if(e instanceof Eo||(e=$o(e)),!e)return new Qa;if(e instanceof Qa)return e;e=e.rgb();var t=e.r/255,r=e.g/255,s=e.b/255,o=Math.min(t,r,s),c=Math.max(t,r,s),_=NaN,m=c-o,b=(c+o)/2;return m?(t===c?_=(r-s)/m+(r<s)*6:r===c?_=(s-t)/m+2:_=(t-r)/m+4,m/=b<.5?c+o:2-c-o,_*=60):m=b>0&&b<1?0:_,new Qa(_,m,b,e.opacity)}function Dh(e,t,r,s){return arguments.length===1?eu(e):new Qa(e,t,r,s==null?1:s)}function Qa(e,t,r,s){this.h=+e,this.s=+t,this.l=+r,this.opacity=+s}vl(Qa,Dh,Jl(Eo,{brighter(e){return e=e==null?Oo:Math.pow(Oo,e),new Qa(this.h,this.s,this.l*e,this.opacity)},darker(e){return e=e==null?yo:Math.pow(yo,e),new Qa(this.h,this.s,this.l*e,this.opacity)},rgb(){var e=this.h%360+(this.h<0)*360,t=isNaN(e)||isNaN(this.s)?0:this.s,r=this.l,s=r+(r<.5?r:1-r)*t,o=2*r-s;return new En(rl(e>=240?e-240:e+120,o,s),rl(e,o,s),rl(e<120?e+240:e-120,o,s),this.opacity)},clamp(){return new Qa(Ql(this.h),Vo(this.s),Vo(this.l),Ko(this.opacity))},displayable(){return(0<=this.s&&this.s<=1||isNaN(this.s))&&0<=this.l&&this.l<=1&&0<=this.opacity&&this.opacity<=1},formatHsl(){const e=Ko(this.opacity);return`${e===1?"hsl(":"hsla("}${Ql(this.h)}, ${Vo(this.s)*100}%, ${Vo(this.l)*100}%${e===1?")":`, ${e})`}`}}));function Ql(e){return e=(e||0)%360,e<0?e+360:e}function Vo(e){return Math.max(0,Math.min(1,e||0))}function rl(e,t,r){return(e<60?t+(r-t)*e/60:e<180?r:e<240?t+(r-t)*(240-e)/60:t)*255}const bl=e=>()=>e;function Wh(e,t){return function(r){return e+r*t}}function zh(e,t,r){return e=Math.pow(e,r),t=Math.pow(t,r)-e,r=1/r,function(s){return Math.pow(e+s*t,r)}}function jh(e){return(e=+e)==1?tu:function(t,r){return r-t?zh(t,r,e):bl(isNaN(t)?r:t)}}function tu(e,t){var r=t-e;return r?Wh(e,r):bl(isNaN(e)?t:e)}const Rl=function e(t){var r=jh(t);function s(o,c){var _=r((o=hl(o)).r,(c=hl(c)).r),m=r(o.g,c.g),b=r(o.b,c.b),v=tu(o.opacity,c.opacity);return function(k){return o.r=_(k),o.g=m(k),o.b=b(k),o.opacity=v(k),o+""}}return s.gamma=e,s}(1);function Vh(e,t){t||(t=[]);var r=e?Math.min(t.length,e.length):0,s=t.slice(),o;return function(c){for(o=0;o<r;++o)s[o]=e[o]*(1-c)+t[o]*c;return s}}function Uh(e){return ArrayBuffer.isView(e)&&!(e instanceof DataView)}function Gh(e,t){var r=t?t.length:0,s=e?Math.min(r,e.length):0,o=new Array(s),c=new Array(r),_;for(_=0;_<s;++_)o[_]=gl(e[_],t[_]);for(;_<r;++_)c[_]=t[_];return function(m){for(_=0;_<s;++_)c[_]=o[_](m);return c}}function Oh(e,t){var r=new Date;return e=+e,t=+t,function(s){return r.setTime(e*(1-s)+t*s),r}}function Zo(e,t){return e=+e,t=+t,function(r){return e*(1-r)+t*r}}function Kh(e,t){var r={},s={},o;(e===null||typeof e!="object")&&(e={}),(t===null||typeof t!="object")&&(t={});for(o in t)o in e?r[o]=gl(e[o],t[o]):s[o]=t[o];return function(c){for(o in r)s[o]=r[o](c);return s}}var fl=/[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,sl=new RegExp(fl.source,"g");function Zh(e){return function(){return e}}function Xh(e){return function(t){return e(t)+""}}function Yh(e,t){var r=fl.lastIndex=sl.lastIndex=0,s,o,c,_=-1,m=[],b=[];for(e=e+"",t=t+"";(s=fl.exec(e))&&(o=sl.exec(t));)(c=o.index)>r&&(c=t.slice(r,c),m[_]?m[_]+=c:m[++_]=c),(s=s[0])===(o=o[0])?m[_]?m[_]+=o:m[++_]=o:(m[++_]=null,b.push({i:_,x:Zo(s,o)})),r=sl.lastIndex;return r<t.length&&(c=t.slice(r),m[_]?m[_]+=c:m[++_]=c),m.length<2?b[0]?Xh(b[0].x):Zh(t):(t=b.length,function(v){for(var k=0,w;k<t;++k)m[(w=b[k]).i]=w.x(v);return m.join("")})}function gl(e,t){var r=typeof t,s;return t==null||r==="boolean"?bl(t):(r==="number"?Zo:r==="string"?(s=$o(t))?(t=s,Rl):Yh:t instanceof $o?Rl:t instanceof Date?Oh:Uh(t)?Vh:Array.isArray(t)?Gh:typeof t.valueOf!="function"&&typeof t.toString!="function"||isNaN(t)?Kh:Zo)(e,t)}function Jh(e,t){return e=+e,t=+t,function(r){return Math.round(e*(1-r)+t*r)}}function ef(e){return function(){return e}}function tf(e){return+e}var Cl=[0,1];function Xs(e){return e}function ml(e,t){return(t-=e=+e)?function(r){return(r-e)/t}:ef(isNaN(t)?NaN:.5)}function nf(e,t){var r;return e>t&&(r=e,e=t,t=r),function(s){return Math.max(e,Math.min(t,s))}}function af(e,t,r){var s=e[0],o=e[1],c=t[0],_=t[1];return o<s?(s=ml(o,s),c=r(_,c)):(s=ml(s,o),c=r(c,_)),function(m){return c(s(m))}}function rf(e,t,r){var s=Math.min(e.length,t.length)-1,o=new Array(s),c=new Array(s),_=-1;for(e[s]<e[0]&&(e=e.slice().reverse(),t=t.slice().reverse());++_<s;)o[_]=ml(e[_],e[_+1]),c[_]=r(t[_],t[_+1]);return function(m){var b=Th(e,m,1,s)-1;return c[b](o[b](m))}}function sf(e,t){return t.domain(e.domain()).range(e.range()).interpolate(e.interpolate()).clamp(e.clamp()).unknown(e.unknown())}function of(){var e=Cl,t=Cl,r=gl,s,o,c,_=Xs,m,b,v;function k(){var E=Math.min(e.length,t.length);return _!==Xs&&(_=nf(e[0],e[E-1])),m=E>2?rf:af,b=v=null,w}function w(E){return E==null||isNaN(E=+E)?c:(b||(b=m(e.map(s),t,r)))(s(_(E)))}return w.invert=function(E){return _(o((v||(v=m(t,e.map(s),Zo)))(E)))},w.domain=function(E){return arguments.length?(e=Array.from(E,tf),k()):e.slice()},w.range=function(E){return arguments.length?(t=Array.from(E),k()):t.slice()},w.rangeRound=function(E){return t=Array.from(E),r=Jh,k()},w.clamp=function(E){return arguments.length?(_=E?!0:Xs,k()):_!==Xs},w.interpolate=function(E){return arguments.length?(r=E,k()):r},w.unknown=function(E){return arguments.length?(c=E,w):c},function(E,N){return s=E,o=N,k()}}function lf(){return of()(Xs,Xs)}function uf(e){return Math.abs(e=Math.round(e))>=1e21?e.toLocaleString("en").replace(/,/g,""):e.toString(10)}function Xo(e,t){if((r=(e=t?e.toExponential(t-1):e.toExponential()).indexOf("e"))<0)return null;var r,s=e.slice(0,r);return[s.length>1?s[0]+s.slice(2):s,+e.slice(r+1)]}function eo(e){return e=Xo(Math.abs(e)),e?e[1]:NaN}function hf(e,t){return function(r,s){for(var o=r.length,c=[],_=0,m=e[0],b=0;o>0&&m>0&&(b+m+1>s&&(m=Math.max(1,s-b)),c.push(r.substring(o-=m,o+m)),!((b+=m+1)>s));)m=e[_=(_+1)%e.length];return c.reverse().join(t)}}function ff(e){return function(t){return t.replace(/[0-9]/g,function(r){return e[+r]})}}var mf=/^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;function Yo(e){if(!(t=mf.exec(e)))throw new Error("invalid format: "+e);var t;return new yl({fill:t[1],align:t[2],sign:t[3],symbol:t[4],zero:t[5],width:t[6],comma:t[7],precision:t[8]&&t[8].slice(1),trim:t[9],type:t[10]})}Yo.prototype=yl.prototype;function yl(e){this.fill=e.fill===void 0?" ":e.fill+"",this.align=e.align===void 0?">":e.align+"",this.sign=e.sign===void 0?"-":e.sign+"",this.symbol=e.symbol===void 0?"":e.symbol+"",this.zero=!!e.zero,this.width=e.width===void 0?void 0:+e.width,this.comma=!!e.comma,this.precision=e.precision===void 0?void 0:+e.precision,this.trim=!!e.trim,this.type=e.type===void 0?"":e.type+""}yl.prototype.toString=function(){return this.fill+this.align+this.sign+this.symbol+(this.zero?"0":"")+(this.width===void 0?"":Math.max(1,this.width|0))+(this.comma?",":"")+(this.precision===void 0?"":"."+Math.max(0,this.precision|0))+(this.trim?"~":"")+this.type};function pf(e){e:for(var t=e.length,r=1,s=-1,o;r<t;++r)switch(e[r]){case".":s=o=r;break;case"0":s===0&&(s=r),o=r;break;default:if(!+e[r])break e;s>0&&(s=0);break}return s>0?e.slice(0,s)+e.slice(o+1):e}var nu;function _f(e,t){var r=Xo(e,t);if(!r)return e+"";var s=r[0],o=r[1],c=o-(nu=Math.max(-8,Math.min(8,Math.floor(o/3)))*3)+1,_=s.length;return c===_?s:c>_?s+new Array(c-_+1).join("0"):c>0?s.slice(0,c)+"."+s.slice(c):"0."+new Array(1-c).join("0")+Xo(e,Math.max(0,t+c-1))[0]}function Bl(e,t){var r=Xo(e,t);if(!r)return e+"";var s=r[0],o=r[1];return o<0?"0."+new Array(-o).join("0")+s:s.length>o+1?s.slice(0,o+1)+"."+s.slice(o+1):s+new Array(o-s.length+2).join("0")}const Dl={"%":(e,t)=>(e*100).toFixed(t),b:e=>Math.round(e).toString(2),c:e=>e+"",d:uf,e:(e,t)=>e.toExponential(t),f:(e,t)=>e.toFixed(t),g:(e,t)=>e.toPrecision(t),o:e=>Math.round(e).toString(8),p:(e,t)=>Bl(e*100,t),r:Bl,s:_f,X:e=>Math.round(e).toString(16).toUpperCase(),x:e=>Math.round(e).toString(16)};function Wl(e){return e}var zl=Array.prototype.map,jl=["y","z","a","f","p","n","\xB5","m","","k","M","G","T","P","E","Z","Y"];function cf(e){var t=e.grouping===void 0||e.thousands===void 0?Wl:hf(zl.call(e.grouping,Number),e.thousands+""),r=e.currency===void 0?"":e.currency[0]+"",s=e.currency===void 0?"":e.currency[1]+"",o=e.decimal===void 0?".":e.decimal+"",c=e.numerals===void 0?Wl:ff(zl.call(e.numerals,String)),_=e.percent===void 0?"%":e.percent+"",m=e.minus===void 0?"\u2212":e.minus+"",b=e.nan===void 0?"NaN":e.nan+"";function v(w){w=Yo(w);var E=w.fill,N=w.align,Q=w.sign,K=w.symbol,V=w.zero,L=w.width,z=w.comma,x=w.precision,H=w.trim,I=w.type;I==="n"?(z=!0,I="g"):Dl[I]||(x===void 0&&(x=12),H=!0,I="g"),(V||E==="0"&&N==="=")&&(V=!0,E="0",N="=");var j=K==="$"?r:K==="#"&&/[boxX]/.test(I)?"0"+I.toLowerCase():"",Y=K==="$"?s:/[%p]/.test(I)?_:"",P=Dl[I],re=/[defgprs%]/.test(I);x=x===void 0?6:/[gprs]/.test(I)?Math.max(1,Math.min(21,x)):Math.max(0,Math.min(20,x));function X(D){var M=j,q=Y,ee,B,R;if(I==="c")q=P(D)+q,D="";else{D=+D;var U=D<0||1/D<0;if(D=isNaN(D)?b:P(Math.abs(D),x),H&&(D=pf(D)),U&&+D==0&&Q!=="+"&&(U=!1),M=(U?Q==="("?Q:m:Q==="-"||Q==="("?"":Q)+M,q=(I==="s"?jl[8+nu/3]:"")+q+(U&&Q==="("?")":""),re){for(ee=-1,B=D.length;++ee<B;)if(R=D.charCodeAt(ee),48>R||R>57){q=(R===46?o+D.slice(ee+1):D.slice(ee))+q,D=D.slice(0,ee);break}}}z&&!V&&(D=t(D,1/0));var ie=M.length+D.length+q.length,te=ie<L?new Array(L-ie+1).join(E):"";switch(z&&V&&(D=t(te+D,te.length?L-q.length:1/0),te=""),N){case"<":D=M+D+q+te;break;case"=":D=M+te+D+q;break;case"^":D=te.slice(0,ie=te.length>>1)+M+D+q+te.slice(ie);break;default:D=te+M+D+q;break}return c(D)}return X.toString=function(){return w+""},X}function k(w,E){var N=v((w=Yo(w),w.type="f",w)),Q=Math.max(-8,Math.min(8,Math.floor(eo(E)/3)))*3,K=Math.pow(10,-Q),V=jl[8+Q/3];return function(L){return N(K*L)+V}}return{format:v,formatPrefix:k}}var Uo,au,ru;df({thousands:",",grouping:[3],currency:["$",""]});function df(e){return Uo=cf(e),au=Uo.format,ru=Uo.formatPrefix,Uo}function wf(e){return Math.max(0,-eo(Math.abs(e)))}function vf(e,t){return Math.max(0,Math.max(-8,Math.min(8,Math.floor(eo(t)/3)))*3-eo(Math.abs(e)))}function bf(e,t){return e=Math.abs(e),t=Math.abs(t)-e,Math.max(0,eo(t)-eo(e))+1}function gf(e,t,r,s){var o=Ph(e,t,r),c;switch(s=Yo(s==null?",f":s),s.type){case"s":{var _=Math.max(Math.abs(e),Math.abs(t));return s.precision==null&&!isNaN(c=vf(o,_))&&(s.precision=c),ru(s,_)}case"":case"e":case"g":case"p":case"r":{s.precision==null&&!isNaN(c=bf(o,Math.max(Math.abs(e),Math.abs(t))))&&(s.precision=c-(s.type==="e"));break}case"f":case"%":{s.precision==null&&!isNaN(c=wf(o))&&(s.precision=c-(s.type==="%")*2);break}}return au(s)}function yf(e){var t=e.domain;return e.ticks=function(r){var s=t();return Mh(s[0],s[s.length-1],r==null?10:r)},e.tickFormat=function(r,s){var o=t();return gf(o[0],o[o.length-1],r==null?10:r,s)},e.nice=function(r){r==null&&(r=10);var s=t(),o=0,c=s.length-1,_=s[o],m=s[c],b,v,k=10;for(m<_&&(v=_,_=m,m=v,v=o,o=c,c=v);k-- >0;){if(v=Yl(_,m,r),v===b)return s[o]=_,s[c]=m,t(s);if(v>0)_=Math.floor(_/v)*v,m=Math.ceil(m/v)*v;else if(v<0)_=Math.ceil(_*v)/v,m=Math.floor(m*v)/v;else break;b=v}return e},e}function pl(){var e=lf();return e.copy=function(){return sf(e,pl())},Sh.apply(e,arguments),yf(e)}const _l=Math.PI,cl=2*_l,Fs=1e-6,Nf=cl-Fs;function dl(){this._x0=this._y0=this._x1=this._y1=null,this._=""}function su(){return new dl}dl.prototype=su.prototype={constructor:dl,moveTo:function(e,t){this._+="M"+(this._x0=this._x1=+e)+","+(this._y0=this._y1=+t)},closePath:function(){this._x1!==null&&(this._x1=this._x0,this._y1=this._y0,this._+="Z")},lineTo:function(e,t){this._+="L"+(this._x1=+e)+","+(this._y1=+t)},quadraticCurveTo:function(e,t,r,s){this._+="Q"+ +e+","+ +t+","+(this._x1=+r)+","+(this._y1=+s)},bezierCurveTo:function(e,t,r,s,o,c){this._+="C"+ +e+","+ +t+","+ +r+","+ +s+","+(this._x1=+o)+","+(this._y1=+c)},arcTo:function(e,t,r,s,o){e=+e,t=+t,r=+r,s=+s,o=+o;var c=this._x1,_=this._y1,m=r-e,b=s-t,v=c-e,k=_-t,w=v*v+k*k;if(o<0)throw new Error("negative radius: "+o);if(this._x1===null)this._+="M"+(this._x1=e)+","+(this._y1=t);else if(w>Fs)if(!(Math.abs(k*m-b*v)>Fs)||!o)this._+="L"+(this._x1=e)+","+(this._y1=t);else{var E=r-c,N=s-_,Q=m*m+b*b,K=E*E+N*N,V=Math.sqrt(Q),L=Math.sqrt(w),z=o*Math.tan((_l-Math.acos((Q+w-K)/(2*V*L)))/2),x=z/L,H=z/V;Math.abs(x-1)>Fs&&(this._+="L"+(e+x*v)+","+(t+x*k)),this._+="A"+o+","+o+",0,0,"+ +(k*E>v*N)+","+(this._x1=e+H*m)+","+(this._y1=t+H*b)}},arc:function(e,t,r,s,o,c){e=+e,t=+t,r=+r,c=!!c;var _=r*Math.cos(s),m=r*Math.sin(s),b=e+_,v=t+m,k=1^c,w=c?s-o:o-s;if(r<0)throw new Error("negative radius: "+r);this._x1===null?this._+="M"+b+","+v:(Math.abs(this._x1-b)>Fs||Math.abs(this._y1-v)>Fs)&&(this._+="L"+b+","+v),r&&(w<0&&(w=w%cl+cl),w>Nf?this._+="A"+r+","+r+",0,1,"+k+","+(e-_)+","+(t-m)+"A"+r+","+r+",0,1,"+k+","+(this._x1=b)+","+(this._y1=v):w>Fs&&(this._+="A"+r+","+r+",0,"+ +(w>=_l)+","+k+","+(this._x1=e+r*Math.cos(o))+","+(this._y1=t+r*Math.sin(o))))},rect:function(e,t,r,s){this._+="M"+(this._x0=this._x1=+e)+","+(this._y0=this._y1=+t)+"h"+ +r+"v"+ +s+"h"+-r+"Z"},toString:function(){return this._}};function Ks(e){return function(){return e}}function $f(e){return typeof e=="object"&&"length"in e?e:Array.from(e)}function ou(e){this._context=e}ou.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._point=0},lineEnd:function(){(this._line||this._line!==0&&this._point===1)&&this._context.closePath(),this._line=1-this._line},point:function(e,t){switch(e=+e,t=+t,this._point){case 0:this._point=1,this._line?this._context.lineTo(e,t):this._context.moveTo(e,t);break;case 1:this._point=2;default:this._context.lineTo(e,t);break}}};function Ef(e){return new ou(e)}function kf(e){return e[0]}function Tf(e){return e[1]}function Mf(e,t){var r=Ks(!0),s=null,o=Ef,c=null;e=typeof e=="function"?e:e===void 0?kf:Ks(e),t=typeof t=="function"?t:t===void 0?Tf:Ks(t);function _(m){var b,v=(m=$f(m)).length,k,w=!1,E;for(s==null&&(c=o(E=su())),b=0;b<=v;++b)!(b<v&&r(k=m[b],b,m))===w&&((w=!w)?c.lineStart():c.lineEnd()),w&&c.point(+e(k,b,m),+t(k,b,m));if(E)return c=null,E+""||null}return _.x=function(m){return arguments.length?(e=typeof m=="function"?m:Ks(+m),_):e},_.y=function(m){return arguments.length?(t=typeof m=="function"?m:Ks(+m),_):t},_.defined=function(m){return arguments.length?(r=typeof m=="function"?m:Ks(!!m),_):r},_.curve=function(m){return arguments.length?(o=m,s!=null&&(c=o(s)),_):o},_.context=function(m){return arguments.length?(m==null?s=c=null:c=o(s=m),_):s},_}function Vl(e,t,r){const s=e.slice();return s[10]=t[r],s}function Ul(e,t,r){const s=e.slice();return s[10]=t[r],s}function Gl(e){let t,r,s,o=e[10]+"",c,_;return{c(){t=Yr("g"),r=Yr("line"),s=Yr("text"),c=h(o),this.h()},l(m){t=Jr(m,"g",{transform:!0});var b=u(t);r=Jr(b,"line",{y2:!0,stroke:!0,class:!0}),u(r).forEach(a),s=Jr(b,"text",{"font-size":!0,"text-anchor":!0,y:!0});var v=u(s);c=f(v,o),v.forEach(a),b.forEach(a),this.h()},h(){F(r,"y2","3"),F(r,"stroke","black"),F(r,"class","svelte-e941bf"),F(s,"font-size","5"),F(s,"text-anchor","middle"),F(s,"y","8"),F(t,"transform",_=`translate(${e[5](e[10]).toPrecision(3)}, 102)`)},m(m,b){y(m,t,b),n(t,r),n(t,s),n(s,c)},p(m,b){b&288&&o!==(o=m[10]+"")&&wl(c,o),b&288&&_!==(_=`translate(${m[5](m[10]).toPrecision(3)}, 102)`)&&F(t,"transform",_)},d(m){m&&a(t)}}}function Ol(e){let t,r,s,o=e[10]+"",c,_;return{c(){t=Yr("g"),r=Yr("line"),s=Yr("text"),c=h(o),this.h()},l(m){t=Jr(m,"g",{transform:!0});var b=u(t);r=Jr(b,"line",{x2:!0,stroke:!0,class:!0}),u(r).forEach(a),s=Jr(b,"text",{"font-size":!0,"text-anchor":!0,x:!0,y:!0});var v=u(s);c=f(v,o),v.forEach(a),b.forEach(a),this.h()},h(){F(r,"x2","-3"),F(r,"stroke","black"),F(r,"class","svelte-e941bf"),F(s,"font-size","5"),F(s,"text-anchor","end"),F(s,"x","-6"),F(s,"y","1.5"),F(t,"transform",_=`translate(-2, ${(100-e[4](e[10])).toPrecision(3)})`)},m(m,b){y(m,t,b),n(t,r),n(t,s),n(s,c)},p(m,b){b&272&&o!==(o=m[10]+"")&&wl(c,o),b&272&&_!==(_=`translate(-2, ${(100-m[4](m[10])).toPrecision(3)})`)&&F(t,"transform",_)},d(m){m&&a(t)}}}function Kl(e){let t,r,s,o;return{c(){t=Yr("path"),this.h()},l(c){t=Jr(c,"path",{d:!0,stroke:!0,class:!0}),u(t).forEach(a),this.h()},h(){F(t,"d",r=e[7](e[0])),F(t,"stroke",e[2]),F(t,"class","svelte-e941bf")},m(c,_){y(c,t,_),o=!0},p(c,_){(!o||_&129&&r!==(r=c[7](c[0])))&&F(t,"d",r),(!o||_&4)&&F(t,"stroke",c[2])},i(c){o||(Tu(()=>{s||(s=Tl(t,Pl,{duration:2e3},!0)),s.run(1)}),o=!0)},o(c){s||(s=Tl(t,Pl,{duration:2e3},!1)),s.run(0),o=!1},d(c){c&&a(t),c&&s&&s.end()}}}function Pf(e){let t,r,s,o,c,_=e[5].ticks(zo(e[8],10)),m=[];for(let w=0;w<_.length;w+=1)m[w]=Gl(Ul(e,_,w));let b=e[4].ticks(zo(e[8],7)),v=[];for(let w=0;w<b.length;w+=1)v[w]=Ol(Vl(e,b,w));let k=e[1]&&Kl(e);return{c(){t=Yr("svg");for(let w=0;w<m.length;w+=1)m[w].c();r=Zs();for(let w=0;w<v.length;w+=1)v[w].c();s=Zs(),k&&k.c(),this.h()},l(w){t=Jr(w,"svg",{width:!0,height:!0,viewBox:!0});var E=u(t);for(let N=0;N<m.length;N+=1)m[N].l(E);r=Zs();for(let N=0;N<v.length;N+=1)v[N].l(E);s=Zs(),k&&k.l(E),E.forEach(a),this.h()},h(){F(t,"width","100%"),F(t,"height",e[3]),F(t,"viewBox",o="-15 -10 "+(e[6]+15)+" 120")},m(w,E){y(w,t,E);for(let N=0;N<m.length;N+=1)m[N].m(t,null);n(t,r);for(let N=0;N<v.length;N+=1)v[N].m(t,null);n(t,s),k&&k.m(t,null),c=!0},p(w,[E]){if(E&288){_=w[5].ticks(zo(w[8],10));let N;for(N=0;N<_.length;N+=1){const Q=Ul(w,_,N);m[N]?m[N].p(Q,E):(m[N]=Gl(Q),m[N].c(),m[N].m(t,r))}for(;N<m.length;N+=1)m[N].d(1);m.length=_.length}if(E&272){b=w[4].ticks(zo(w[8],7));let N;for(N=0;N<b.length;N+=1){const Q=Vl(w,b,N);v[N]?v[N].p(Q,E):(v[N]=Ol(Q),v[N].c(),v[N].m(t,s))}for(;N<v.length;N+=1)v[N].d(1);v.length=b.length}w[1]?k?(k.p(w,E),E&2&&Pe(k,1)):(k=Kl(w),k.c(),Pe(k,1),k.m(t,null)):k&&(Eu(),Se(k,1,1,()=>{k=null}),ku()),(!c||E&8)&&F(t,"height",w[3]),(!c||E&64&&o!==(o="-15 -10 "+(w[6]+15)+" 120"))&&F(t,"viewBox",o)},i(w){c||(Pe(k),c=!0)},o(w){Se(k),c=!1},d(w){w&&a(t),kl(m,w),kl(v,w),k&&k.d()}}}function Sf(e,t,r){let s,o,c,_,m,{data:b}=t,{show:v}=t,{strokeColor:k="#8A2BE2"}=t,{height:w=300}=t,{aspectRatio:E=2}=t;return e.$$set=N=>{"data"in N&&r(0,b=N.data),"show"in N&&r(1,v=N.show),"strokeColor"in N&&r(2,k=N.strokeColor),"height"in N&&r(3,w=N.height),"aspectRatio"in N&&r(9,E=N.aspectRatio)},e.$$.update=()=>{e.$$.dirty&1&&r(8,s=b.length),e.$$.dirty&512&&r(6,o=E*100),e.$$.dirty&65&&r(5,c=pl().domain(Sl(b.map(N=>N.x))).range([0,o])),e.$$.dirty&1&&r(4,_=pl().domain(Sl(b.map(N=>N.y))).range([0,100])),e.$$.dirty&48&&r(7,m=Mf().x(N=>c(N.x)).y(N=>100-_(N.y)))},[b,v,k,w,_,c,o,m,s,E]}class Zl extends va{constructor(t){super(),ba(this,t,Sf,Pf,ga,{data:0,show:1,strokeColor:2,height:3,aspectRatio:9})}}function Af(e){let t,r,s,o,c,_,m=p(`x = ${e[0]}`)+"",b,v,k,w,E,N,Q,K,V,L,z,x,H,I,j,Y,P,re,X,D,M,q,ee,B;return t=new gh({}),j=new Zl({props:{data:e[3],show:!0,aspectRatio:3}}),M=new Zl({props:{data:e[2],show:!0,aspectRatio:3,strokeColor:"#A0522D"}}),{c(){Le(t.$$.fragment),r=S(),s=i("div"),o=i("div"),c=i("div"),_=i("span"),b=S(),v=i("input"),k=S(),w=i("div"),E=i("span"),N=h(e[1]),Q=h(" qubits"),K=S(),V=i("input"),L=S(),z=i("div"),x=i("p"),H=h("Real part"),I=S(),Le(j.$$.fragment),Y=S(),P=i("div"),re=i("p"),X=h("Imaginary part"),D=S(),Le(M.$$.fragment),this.h()},l(R){qe(t.$$.fragment,R),r=A(R),s=l(R,"DIV",{class:!0});var U=u(s);o=l(U,"DIV",{class:!0});var ie=u(o);c=l(ie,"DIV",{class:!0});var te=u(c);_=l(te,"SPAN",{class:!0});var Ee=u(_);Ee.forEach(a),b=A(te),v=l(te,"INPUT",{type:!0,min:!0,max:!0,step:!0,class:!0}),te.forEach(a),k=A(ie),w=l(ie,"DIV",{class:!0});var he=u(w);E=l(he,"SPAN",{class:!0});var Z=u(E);N=f(Z,e[1]),Q=f(Z," qubits"),Z.forEach(a),K=A(he),V=l(he,"INPUT",{type:!0,min:!0,max:!0,step:!0,class:!0}),he.forEach(a),ie.forEach(a),L=A(U),z=l(U,"DIV",{class:!0});var T=u(z);x=l(T,"P",{});var J=u(x);H=f(J,"Real part"),J.forEach(a),I=A(T),qe(j.$$.fragment,T),T.forEach(a),Y=A(U),P=l(U,"DIV",{});var de=u(P);re=l(de,"P",{});var We=u(re);X=f(We,"Imaginary part"),We.forEach(a),D=A(de),qe(M.$$.fragment,de),de.forEach(a),U.forEach(a),this.h()},h(){F(_,"class","label svelte-1k89lhb"),F(v,"type","range"),F(v,"min",0),F(v,"max",10),F(v,"step",1),F(v,"class","svelte-1k89lhb"),F(c,"class","col-lg-6 col-sm-12"),F(E,"class","label svelte-1k89lhb"),F(V,"type","range"),F(V,"min",3),F(V,"max",10),F(V,"step",1),F(V,"class","svelte-1k89lhb"),F(w,"class","col-lg-6 col-sm-12"),F(o,"class","row"),F(z,"class","mb-3"),F(s,"class","interaction container")},m(R,U){xe(t,R,U),y(R,r,U),y(R,s,U),n(s,o),n(o,c),n(c,_),_.innerHTML=m,n(c,b),n(c,v),Ct(v,e[0]),n(o,k),n(o,w),n(w,E),n(E,N),n(E,Q),n(w,K),n(w,V),Ct(V,e[1]),n(s,L),n(s,z),n(z,x),n(x,H),n(z,I),xe(j,z,null),n(s,Y),n(s,P),n(P,re),n(re,X),n(P,D),xe(M,P,null),q=!0,ee||(B=[d(v,"change",e[6]),d(v,"input",e[6]),d(V,"change",e[7]),d(V,"input",e[7])],ee=!0)},p(R,[U]){(!q||U&1)&&m!==(m=p(`x = ${R[0]}`)+"")&&(_.innerHTML=m),U&1&&Ct(v,R[0]),(!q||U&2)&&wl(N,R[1]),U&2&&Ct(V,R[1]);const ie={};U&8&&(ie.data=R[3]),j.$set(ie);const te={};U&4&&(te.data=R[2]),M.$set(te)},i(R){q||(Pe(t.$$.fragment,R),Pe(j.$$.fragment,R),Pe(M.$$.fragment,R),q=!0)},o(R){Se(t.$$.fragment,R),Se(j.$$.fragment,R),Se(M.$$.fragment,R),q=!1},d(R){Ie(t,R),R&&a(r),R&&a(s),Ie(j),Ie(M),ee=!1,es(B)}}}function Hf(e,t,r){let s,o,c,_,m,b;function v(){o=vr(this.value),r(0,o)}function k(){s=vr(this.value),r(1,s)}return e.$$.update=()=>{e.$$.dirty&2&&r(5,c=Ml(2,s)),e.$$.dirty&33&&r(4,b=[...Array(c).keys()].map(w=>Ml(Pu,Su(2*ol*o*w/c,Au)))),e.$$.dirty&16&&r(3,_=b.map((w,E)=>({x:E,y:w.im}))),e.$$.dirty&16&&r(2,m=b.map((w,E)=>({x:E,y:w.re})))},r(1,s=3),r(0,o=9),[o,s,m,_,b,c,v,k]}class Lf extends va{constructor(t){super(),ba(this,t,Hf,Af,ga,{})}}const qf='<a href="https://en.wikipedia.org/wiki/Separable_state"><h3>Separable state</h3></a><p>In quantum mechanics, <b>separable states</b> are quantum states belonging to a composite space that can be factored into individual states belonging to separate subspaces. A state is said to be entangled if it is not separable. In general, determining if a state is separable is not straightforward and the problem is classed as NP-hard.</p>',xf='<a href="https://en.wikipedia.org/wiki/Quantum_entanglement"><h3>Quantum entanglement</h3></a><p><b>Quantum entanglement</b> is the physical phenomenon that occurs when a group of particles are generated, interact, or share spatial proximity in a way such that the quantum state of each particle of the group cannot be described independently of the state of the others, including when the particles are separated by a large distance. The topic of quantum entanglement is at the heart of the disparity between classical and quantum physics: entanglement is a primary feature of quantum mechanics lacking in classical mechanics.</p>',If='<a href="https://en.wikipedia.org/wiki/Quantum_register"><h3>Quantum register</h3></a><p>In quantum computing, a <b>quantum register</b> is a system comprising multiple qubits. It is the quantum analogue of the classical processor register. Quantum computers perform calculations by manipulating qubits within a quantum register.</p>';function Ff(e){let t;return{c(){t=h("separable")},l(r){t=f(r,"separable")},m(r,s){y(r,t,s)},d(r){r&&a(t)}}}function Qf(e){let t;return{c(){t=h("entaglement")},l(r){t=f(r,"entaglement")},m(r,s){y(r,t,s)},d(r){r&&a(t)}}}function Rf(e){let t;return{c(){t=h("quantum register")},l(r){t=f(r,"quantum register")},m(r,s){y(r,t,s)},d(r){r&&a(t)}}}function Cf(e){let t,r,s,o,c,_,m,b,v,k,w=p("|0\\rangle,")+"",E,N,Q=p("|1\\rangle,")+"",K,V,L,z,x,H,I,j=p("|\\psi\\rangle")+"",Y,P,re=p("n")+"",X,D,M=p("|\\psi\\rangle = \\left( \\alpha_1 |0\\rangle + \\beta_1 |1\\rangle \\right) \\otimes ... \\otimes \\left( \\alpha_n |0\\rangle + \\beta_n |1\\rangle \\right),")+"",q,ee,B=p("\\alpha_k, \\beta_k")+"",R,U,ie=p("k")+"",te,Ee,he=p("\\otimes")+"",Z,T,J,de,We,be,je;return _=new Rt({props:{hovertext:qf,$$slots:{default:[Ff]},$$scope:{ctx:e}}}),b=new Rt({props:{hovertext:xf,$$slots:{default:[Qf]},$$scope:{ctx:e}}}),x=new Rt({props:{hovertext:If,$$slots:{default:[Rf]},$$scope:{ctx:e}}}),{c(){t=i("h2"),r=h("Multiple qubits"),s=S(),o=i("p"),c=h("Most quantum algorithms require not only one, but several qubits. The states of these qubits may be "),Le(_.$$.fragment),m=h(", meaning they each contain one independent unit of information. However, it is possible for multiple qubits to share some information with each other, in which case they no longer have states of their own, but only one joint state. This is called "),Le(b.$$.fragment),v=h(", and it is another fundamental difference between classical and quantum computing. As an example, two qubits can be entangled in a way that, if we look at one of them and find it's in the basis state "),k=i("span"),E=h(" we learn immediately that the other one must be in the basis state "),N=i("span"),K=h(" and vice versa."),V=S(),L=i("p"),z=h("From now on, we'll refer to a sequence of qubits as a "),Le(x.$$.fragment),H=h(". Let "),I=i("span"),Y=h(" denote the state of a register consisting of "),P=i("span"),X=h(" qubits. If the qubits are separable, the state can be written as "),D=i("span"),q=h(" where "),ee=i("span"),R=h(" are the coefficients associated with the state of the "),U=i("span"),te=h("-th qubit as described above, and the operator "),Ee=i("span"),Z=h(" indicates that none of the qubits are entagled with each other."),T=S(),J=i("p"),de=h("Note that the state of the register can also be written as a vector, but what you saw above and what we're going to use in the rest of the explanation is the alternative, so called Dirac or bra-ket notation.")},l(ne){t=l(ne,"H2",{});var ae=u(t);r=f(ae,"Multiple qubits"),ae.forEach(a),s=A(ne),o=l(ne,"P",{});var ye=u(o);c=f(ye,"Most quantum algorithms require not only one, but several qubits. The states of these qubits may be "),qe(_.$$.fragment,ye),m=f(ye,", meaning they each contain one independent unit of information. However, it is possible for multiple qubits to share some information with each other, in which case they no longer have states of their own, but only one joint state. This is called "),qe(b.$$.fragment,ye),v=f(ye,", and it is another fundamental difference between classical and quantum computing. As an example, two qubits can be entangled in a way that, if we look at one of them and find it's in the basis state "),k=l(ye,"SPAN",{});var lt=u(k);lt.forEach(a),E=f(ye," we learn immediately that the other one must be in the basis state "),N=l(ye,"SPAN",{});var we=u(N);we.forEach(a),K=f(ye," and vice versa."),ye.forEach(a),V=A(ne),L=l(ne,"P",{});var fe=u(L);z=f(fe,"From now on, we'll refer to a sequence of qubits as a "),qe(x.$$.fragment,fe),H=f(fe,". Let "),I=l(fe,"SPAN",{});var Ve=u(I);Ve.forEach(a),Y=f(fe," denote the state of a register consisting of "),P=l(fe,"SPAN",{});var ut=u(P);ut.forEach(a),X=f(fe," qubits. If the qubits are separable, the state can be written as "),D=l(fe,"SPAN",{});var He=u(D);He.forEach(a),q=f(fe," where "),ee=l(fe,"SPAN",{});var ke=u(ee);ke.forEach(a),R=f(fe," are the coefficients associated with the state of the "),U=l(fe,"SPAN",{});var st=u(U);st.forEach(a),te=f(fe,"-th qubit as described above, and the operator "),Ee=l(fe,"SPAN",{});var Ue=u(Ee);Ue.forEach(a),Z=f(fe," indicates that none of the qubits are entagled with each other."),fe.forEach(a),T=A(ne),J=l(ne,"P",{});var yt=u(J);de=f(yt,"Note that the state of the register can also be written as a vector, but what you saw above and what we're going to use in the rest of the explanation is the alternative, so called Dirac or bra-ket notation."),yt.forEach(a)},m(ne,ae){y(ne,t,ae),n(t,r),y(ne,s,ae),y(ne,o,ae),n(o,c),xe(_,o,null),n(o,m),xe(b,o,null),n(o,v),n(o,k),k.innerHTML=w,n(o,E),n(o,N),N.innerHTML=Q,n(o,K),y(ne,V,ae),y(ne,L,ae),n(L,z),xe(x,L,null),n(L,H),n(L,I),I.innerHTML=j,n(L,Y),n(L,P),P.innerHTML=re,n(L,X),n(L,D),D.innerHTML=M,n(L,q),n(L,ee),ee.innerHTML=B,n(L,R),n(L,U),U.innerHTML=ie,n(L,te),n(L,Ee),Ee.innerHTML=he,n(L,Z),y(ne,T,ae),y(ne,J,ae),n(J,de),We=!0,be||(je=[d(k,"mouseenter",e[0]),d(N,"mouseenter",e[1]),d(I,"mouseenter",e[2]),d(P,"mouseenter",e[3]),d(D,"mouseenter",e[4]),d(ee,"mouseenter",e[5]),d(U,"mouseenter",e[6]),d(Ee,"mouseenter",e[7])],be=!0)},p(ne,[ae]){const ye={};ae&256&&(ye.$$scope={dirty:ae,ctx:ne}),_.$set(ye);const lt={};ae&256&&(lt.$$scope={dirty:ae,ctx:ne}),b.$set(lt);const we={};ae&256&&(we.$$scope={dirty:ae,ctx:ne}),x.$set(we)},i(ne){We||(Pe(_.$$.fragment,ne),Pe(b.$$.fragment,ne),Pe(x.$$.fragment,ne),We=!0)},o(ne){Se(_.$$.fragment,ne),Se(b.$$.fragment,ne),Se(x.$$.fragment,ne),We=!1},d(ne){ne&&a(t),ne&&a(s),ne&&a(o),Ie(_),Ie(b),ne&&a(V),ne&&a(L),Ie(x),ne&&a(T),ne&&a(J),be=!1,es(je)}}}function Xr(e){console.log(e)}function Bf(e){return[()=>Xr([]),()=>Xr([]),()=>Xr(["\\psi"]),()=>Xr(["n"]),()=>Xr(["\\psi","n","\\alpha","\\beta"]),()=>Xr(["k","\\alpha","\\beta"]),()=>Xr(["k"]),()=>Xr([])]}class Df extends va{constructor(t){super(),ba(this,t,Bf,Cf,ga,{})}}function Wf(e){let t,r,s,o,c,_,m,b,v,k,w,E,N,Q,K=p("\\phi_\\alpha")+"",V,L,z,x=p("\\phi_\\beta")+"",H,I,j,Y=p("r_\\alpha")+"",P,re,X,D,M,q,ee,B,R,U,ie,te,Ee,he,Z;return o=new Hu({}),B=new qu({props:{displayBloch:e[2],phiAlpha:e[4],phiBeta:e[3],rAlpha:e[5],blochClass:"col-lg-4 col-sm-12",vectorClass:"col-lg-4 col-sm-12"}}),U=new Lu({}),te=new Df({}),{c(){t=i("h2"),r=h("Quantum Basics"),s=S(),Le(o.$$.fragment),c=S(),_=i("div"),m=i("div"),b=i("div"),v=i("p"),k=h(`Play around with 2 representations of a single qubit. You adjust the view of the 3D Bloch
				sphere by clicking on the image and dragging.`),w=S(),E=i("div"),N=i("div"),Q=new Qe(!1),V=i("input"),L=S(),z=new Qe(!1),H=i("input"),I=S(),j=new Qe(!1),P=i("input"),re=S(),X=i("b"),D=h("Display Bloch sphere"),M=S(),q=i("input"),ee=S(),Le(B.$$.fragment),R=S(),Le(U.$$.fragment),ie=S(),Le(te.$$.fragment),this.h()},l(T){t=l(T,"H2",{});var J=u(t);r=f(J,"Quantum Basics"),J.forEach(a),s=A(T),qe(o.$$.fragment,T),c=A(T),_=l(T,"DIV",{class:!0});var de=u(_);m=l(de,"DIV",{class:!0});var We=u(m);b=l(We,"DIV",{class:!0});var be=u(b);v=l(be,"P",{});var je=u(v);k=f(je,`Play around with 2 representations of a single qubit. You adjust the view of the 3D Bloch
				sphere by clicking on the image and dragging.`),je.forEach(a),be.forEach(a),We.forEach(a),w=A(de),E=l(de,"DIV",{class:!0});var ne=u(E);N=l(ne,"DIV",{class:!0});var ae=u(N);Q=Re(ae,!1),V=l(ae,"INPUT",{type:!0,min:!0,max:!0,step:!0,class:!0}),L=A(ae),z=Re(ae,!1),H=l(ae,"INPUT",{type:!0,min:!0,max:!0,step:!0,class:!0}),I=A(ae),j=Re(ae,!1),P=l(ae,"INPUT",{type:!0,min:!0,max:!0,step:!0,class:!0}),re=A(ae),X=l(ae,"B",{});var ye=u(X);D=f(ye,"Display Bloch sphere"),ye.forEach(a),M=A(ae),q=l(ae,"INPUT",{type:!0,style:!0,class:!0}),ae.forEach(a),ee=A(ne),qe(B.$$.fragment,ne),ne.forEach(a),de.forEach(a),R=A(T),qe(U.$$.fragment,T),ie=A(T),qe(te.$$.fragment,T),this.h()},h(){F(b,"class","col-12"),F(m,"class","row mb-4"),Q.a=V,F(V,"type","range"),F(V,"min",0),F(V,"max",360),F(V,"step",1),F(V,"class","svelte-unwbto"),z.a=H,F(H,"type","range"),F(H,"min",0),F(H,"max",360),F(H,"step",1),F(H,"class","svelte-unwbto"),j.a=P,F(P,"type","range"),F(P,"min",0),F(P,"max",1),F(P,"step",.01),F(P,"class","svelte-unwbto"),F(q,"type","checkbox"),Mu(q,"width","auto"),F(q,"class","svelte-unwbto"),F(N,"class","col-lg-4 col-sm-12"),F(E,"class","row"),F(_,"class","interaction container")},m(T,J){y(T,t,J),n(t,r),y(T,s,J),xe(o,T,J),y(T,c,J),y(T,_,J),n(_,m),n(m,b),n(b,v),n(v,k),n(_,w),n(_,E),n(E,N),Q.m(K,N),n(N,V),Ct(V,e[1]),n(N,L),z.m(x,N),n(N,H),Ct(H,e[0]),n(N,I),j.m(Y,N),n(N,P),Ct(P,e[5]),n(N,re),n(N,X),n(X,D),n(N,M),n(N,q),q.checked=e[2],n(E,ee),xe(B,E,null),y(T,R,J),xe(U,T,J),y(T,ie,J),xe(te,T,J),Ee=!0,he||(Z=[d(V,"change",e[6]),d(V,"input",e[6]),d(H,"change",e[7]),d(H,"input",e[7]),d(P,"change",e[8]),d(P,"input",e[8]),d(q,"change",e[9])],he=!0)},p(T,[J]){J&2&&Ct(V,T[1]),J&1&&Ct(H,T[0]),J&32&&Ct(P,T[5]),J&4&&(q.checked=T[2]);const de={};J&4&&(de.displayBloch=T[2]),J&16&&(de.phiAlpha=T[4]),J&8&&(de.phiBeta=T[3]),J&32&&(de.rAlpha=T[5]),B.$set(de)},i(T){Ee||(Pe(o.$$.fragment,T),Pe(B.$$.fragment,T),Pe(U.$$.fragment,T),Pe(te.$$.fragment,T),Ee=!0)},o(T){Se(o.$$.fragment,T),Se(B.$$.fragment,T),Se(U.$$.fragment,T),Se(te.$$.fragment,T),Ee=!1},d(T){T&&a(t),T&&a(s),Ie(o,T),T&&a(c),T&&a(_),Ie(B),T&&a(R),Ie(U,T),T&&a(ie),Ie(te,T),he=!1,es(Z)}}}function zf(e,t,r){let s,o,c,_,m,b=!0;function v(){s=vr(this.value),r(1,s)}function k(){o=vr(this.value),r(0,o)}function w(){c=vr(this.value),r(5,c)}function E(){b=this.checked,r(2,b)}return e.$$.update=()=>{e.$$.dirty&2&&r(4,_=s/180*ol),e.$$.dirty&1&&r(3,m=o/180*ol)},r(1,s=15),r(0,o=310),r(5,c=.9),[o,s,b,m,_,c,v,k,w,E]}class jf extends va{constructor(t){super(),ba(this,t,zf,Wf,ga,{})}}const Vf='<a href="https://en.wikipedia.org/wiki/Periodic_function"><h3 class="text-lg font-semibold">Periodic function</h3></a><p>A <b>periodic function</b> is a function that repeats its values at regular intervals. For example, the trigonometric functions, which repeat at intervals of <span class="mwe-math-element"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/73efd1f6493490b058097060a572606d2c550a06" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align:-0.338ex;width:2.494ex;height:2.176ex" /></span> radians, are periodic functions. Periodic functions are used throughout science to describe oscillations, waves, and other phenomena that exhibit periodicity. Any function that is not periodic is called <b>aperiodic</b>.</p>',Uf='<a href="https://en.wikipedia.org/wiki/Wave_interference"><h3>Wave interference</h3></a><p>In physics, <b>interference</b> is a phenomenon in which two waves combine by adding their displacement together at every single point in space and time, to form a resultant wave of greater, lower, or the same amplitude. <b>Constructive</b> and <b>destructive interference</b> result from the interaction of waves that are correlated or coherent with each other, either because they come from the same source or because they have the same or nearly the same frequency. Interference effects can be observed with all types of waves, for example, light, radio, acoustic, surface water waves, gravity waves, or matter waves.</p>';function Gf(e){let t;return{c(){t=h("periodic")},l(r){t=f(r,"periodic")},m(r,s){y(r,t,s)},d(r){r&&a(t)}}}function Of(e){let t;return{c(){t=h("interfere")},l(r){t=f(r,"interfere")},m(r,s){y(r,t,s)},d(r){r&&a(t)}}}function Kf(e){let t,r,s,o,c,_,m=p("N,")+"",b,v,k=p("1 < \\hat{r} < N")+"",w,E,N=p("f_{a, N}(\\hat{r}) = a^{\\hat{r}} \\mod N = 1.")+"",Q,K,V=p("f_{a, N}")+"",L,z,x,H,I=p("\\hat{r}")+"",j,Y,P,re,X,D=p("g")+"",M,q,ee=p("0 < p,")+"",B,R,U=p("g(x) = g(x + p)")+"",ie,te,Ee=p("x")+"",he,Z,T=p("g.")+"",J,de,We=p("g")+"",be,je,ne=p("p.")+"",ae,ye,lt=p("f_{a, N},")+"",we,fe,Ve=p("\\mathbb{N},")+"",ut,He,ke,st,Ue,yt=p("\\hat{p} \\in \\mathbb{N}")+"",G,pe,le=p("f_{a, N}.")+"",Lt,Ge,Nt=p("f_{a, N}(0) = a^{0} \\mod N = 1 \\mod N = 1,")+"",qt,Oe,$t=p("f_{a, N}(0) = f_{a, N}(0 + \\hat{p}) = f_{a, N}(\\hat{p}) = 1.")+"",kn,Je,Jt=p("\\hat{p}")+"",Tn,et,pt=p("f_{a, N}")+"",On,Be,en=p("1.")+"",tn,nn,an=p("\\hat{r},")+"",rn,Mn,Pn=p("\\hat{r} = \\hat{p}.")+"",sn,Bt,on,oe,ts=p("f_{a, N},")+"",ln,ya,ge,un,Sn,Kn,hn,An,_t,fn,Dt,ns=p("\\log_2N")+"",mn,Wt,as=p("N")+"",pn,zt,rs=p("\\log_2N")+"",_n,Hn,ht,cn,jt,ss=p("\\log_2N \\leq n")+"",dn,Vt,os=p("|\\psi_1\\rangle, |\\psi_2\\rangle")+"",wn,Ut,is=p("|0\\rangle,")+"",xt,Et,Ra=p("|\\psi_1\\rangle = \\underbrace{|0\\rangle \\otimes \\ldots \\otimes |0\\rangle}_\\text{n terms}.")+"",Ca,kt,Zn,Ba,Ze,Tt,Xn,Da=p("H")+"",ft,Yn,Jn=p("|\\psi_1\\rangle = \\underbrace{\\frac{1}{\\sqrt{2}}(|0\\rangle + |1\\rangle) \\otimes \\ldots \\otimes \\frac{1}{\\sqrt{2}}(|0\\rangle + |1\\rangle)}_\\text{n terms}.")+"",ea,ta,Wa=p("\\frac{1}{\\sqrt{2}}")+"",Gt,Xe,ls=p("|\\psi_1\\rangle = \\frac{1}{\\sqrt{2^n}}(|0\\rangle + |1\\rangle) \\otimes \\ldots \\otimes (|0\\rangle + |1\\rangle).")+"",It,Ae,Na,ct,dt=p("x")+"",$a,wt,za=p("x")+"",vn,Ot,Pr=p("0")+"",me,Mt,ja=p("2^n - 1.")+"",gr,Pt,Va=p("|\\psi_1\\rangle = \\displaystyle{\\frac{1}{\\sqrt{2^n}}\\sum_{x=0}^{2^n-1}|x\\rangle}.")+"",yr,Kt,na=p("x,")+"",Sr,ue,ze=p("\\frac{1}{2^n}.")+"",aa,Ye,Ln,De,Fe,ra,Ua,us=p("|1\\rangle,")+"",sa,Ga,hs=p("|\\psi_2\\rangle = \\underbrace{|0\\rangle \\otimes \\ldots \\otimes |0\\rangle}_\\text{n terms}.")+"",oa,Ea,vt=p("y")+"",ia,Oa,fs=p("x.")+"",la,Ka,Ar=p("f_{a, N}(x) = a^x \\mod N.")+"",Ce,Za,ms=p("x")+"",ua,Xa,ps=p("0")+"",ha,Ya,_s=p("2^n - 1,")+"",qn,_e,cs=p("y = a^x \\mod N.")+"",xn,St,Nr,Zt,to=p("x,")+"",$r,In,Ja=p("y = a^x \\mod N")+"",Er,Fn,er=p("x.")+"",fa,tr,Hr=p("\\displaystyle{|\\psi_2\\rangle = \\sum_{x=0}^{2^n - 1} |y\\rangle = \\sum_{x=0}^{2^n - 1} |a^x \\mod N\\rangle}.")+"",ot,Qn,tt,Lr,ce,ma,nr,no=p("y")+"",qr,Xt,ar=p("|\\psi_2,")+"",rr,xr,ao=p("\\psi_1,")+"",sr,Ir,ro=p("y")+"",ds,bn,Fr=p("x,")+"",so,or,Qr=p("y,")+"",oo,ka,Rr=p("x")+"",ws,Ta,gn=p("a^x \\mod N = y.")+"",vs,Rn,Jo=p("x")+"",bs,pa,io=p("f_{a, N}")+"",gs,_a,lo=p("\\hat{p},")+"",ys,Ma,ir=p("\\hat{p}")+"",Ns,ca,uo=p("0 \\leq x_0, \\ldots, x_k < 2^n")+"",$s,Pa,Cr=p("\\displaystyle{|\\psi_1\\rangle = \\sum_{i=0}^{k} |x_i\\rangle},")+"",lr,Br,Cs=p("x_{i + 1} - x_i = \\hat{p}")+"",ur,Cn,ei=p("i < k.")+"",kr,Bn,Es,Tr,it,hr,Dr,Bs=p("x,")+"",yn,fr,Wr=p("\\displaystyle{|\\psi_1\\rangle = \\frac{1}{\\sqrt{2^n}} \\sum_{y=0}^{2^n - 1} e^{\\frac{2 \\pi i x y}{2^n}} |y\\rangle}.")+"",ho,mr,zr=p("x")+"",fo,pr,Ds=p("\\displaystyle{|\\psi_1\\rangle = \\frac{1}{\\sqrt{2^n}} \\sum_{i=0}^{k} \\sum_{x=0}^{2^n - 1} e^{\\frac{2 \\pi i x_i y}{2^n}} |x\\rangle}.")+"",Sa,Dn,mo,Mr,Ne,ks,Wn,ti=p("x,")+"",Ts,zn,ni=p("x.")+"",Ms,jn,ai=p("x_0, \\ldots, x_k.")+"",Ps,Yt,po,_r,jr=p("x_0, \\ldots, x_k,")+"",_o,cr,Vr=p("1.")+"",Ws,bt,Ur,Vn,Gr=p("x")+"",co,Aa,Or=p("x,")+"",Ss,Ha,gt=p("\\frac{j\\cdot N}{\\hat{p}}")+"",As,Un,ri=p("j = 0, \\ldots, \\hat{p} - 1.")+"",Hs,La,wo,zs;return z=new Rt({props:{hovertext:Vf,$$slots:{default:[Gf]},$$scope:{ctx:e}}}),Yt=new Rt({props:{hovertext:Uf,$$slots:{default:[Of]},$$scope:{ctx:e}}}),{c(){t=i("h2"),r=h("The period-finding problem"),s=S(),o=i("p"),c=h("Recall the steps for computing the prime factors of a large integer "),_=i("span"),b=h(" the hard part of which was finding the smallest "),v=i("span"),w=h(" such that "),E=i("span"),Q=h(" It turns out that "),K=i("span"),L=h(" is a "),Le(z.$$.fragment),x=h(" function, and below we'll show that the number "),H=i("span"),j=h(" we're looking for is exactly its period."),Y=S(),P=i("p"),re=h("In general, the period of a function "),X=i("span"),M=h(" is defined as the smallest positive number "),q=i("span"),B=h(" for which "),R=i("span"),ie=h(" for all "),te=i("span"),he=h(" in the domain of "),Z=i("span"),J=h(" (In other words, "),de=i("span"),be=h(" is a repeating sequence of the same pattern with length "),je=i("span"),ae=h(") Specifically for "),ye=i("span"),we=h(" because its domain is "),fe=i("span"),ut=h(" its period has to be an integer."),He=S(),ke=i("p"),st=h("Let "),Ue=i("span"),G=h(" denote the period of "),pe=i("span"),Lt=h(" We know for sure that "),Ge=i("span"),qt=h(" from which follows that "),Oe=i("span"),kn=h(" Thus, the "),Je=i("span"),Tn=h(" is the smallest positive integer, for which the value of "),et=i("span"),On=h(" equals "),Be=i("span"),tn=h(" Notice that this is exactly how we originally defined "),nn=i("span"),rn=h(" and so "),Mn=i("span"),sn=S(),Bt=i("p"),on=h("Thus, the factoring problem can essentially be reformulated as the problem of finding the period of the function "),oe=i("span"),ln=h(" for which the quantum Fourier transform turns out to be really useful."),ya=S(),ge=i("h2"),un=h("The algorithm"),Sn=S(),Kn=i("h4"),hn=h("Step 1."),An=S(),_t=i("p"),fn=h("In order to implement Shor's algorithm, we'll need two quantum register with at least "),Dt=i("span"),mn=h(" qubits, as that is the number of digits required to represent "),Wt=i("span"),pn=h(" in binary notation. (In case "),zt=i("span"),_n=h(" is not an integer, we have to round it up.) Note that this is a lower limit, and the more qubits we use, the faster we'll find the solution."),Hn=S(),ht=i("p"),cn=h("Let "),jt=i("span"),dn=h(" denote the number of qubits we chose to construct the both registers, and "),Vt=i("span"),wn=h(" the current state of the two registers. Let's ignore the second register for now, and start with all qubits of the first register being in the basis state "),Ut=i("span"),xt=h(" thus we can write its state as "),Et=i("span"),Ca=S(),kt=i("h4"),Zn=h("Step 2."),Ba=S(),Ze=i("p"),Tt=h("Next, we apply the so called "),Xn=i("span"),ft=h(" (Hadamard) gate to each qubit of the first register, in order to set them into an equal superposition of the two basis states. This means the state of the register is now "),Yn=i("span"),ea=h(" We can factor out the "),ta=i("span"),Gt=h(" terms to obtain "),Xe=i("span"),It=S(),Ae=i("p"),Na=h("Let "),ct=i("span"),$a=h(" denote the number represented by the qubits of the first register (that is, the number we get if we read out the state as a sequence of binary digits). As we already saw in the case of the QFT, each qubit being in an equal superposition of the two basis states translates to the entire register being in the superposition of all combinations of these basis states, and consequently "),wt=i("span"),vn=h(" being in the superposition of all values from "),Ot=i("span"),me=h(" to "),Mt=i("span"),gr=h(" Let's express the state as the superposition of these values: "),Pt=i("span"),yr=h(" Thus, if we now measure the entire register and read out "),Kt=i("span"),Sr=h(" we're going to get each possible value with an equal probability of "),ue=i("span"),aa=S(),Ye=i("h4"),Ln=h("Step 3."),De=S(),Fe=i("p"),ra=h("This is the point where the second register enters the picture. We begin with all qubits of this register being in the basis state "),Ua=i("span"),sa=h(" so "),Ga=i("span"),oa=h(" Let "),Ea=i("span"),ia=h(" denote the number represented by the second register, analogously to "),Oa=i("span"),la=h(" Next, we apply a combination of gates to entangle the qubits of the two registers in a special way, in order to implement the function "),Ka=i("span"),Ce=h(" To see what this means, let's take a step back and assume all qubits of the first register are in one particular basis state, and so "),Za=i("span"),ua=h(" is a definite value between "),Xa=i("span"),ha=h(" and "),Ya=i("span"),qn=h(" instead of a superposition of values. If we now applied the current step of the algorithm to the registers, it would set "),_e=i("span"),xn=S(),St=i("p"),Nr=h("But because in our case the first register is actually in a superposition of all possible values of "),Zt=i("span"),$r=h(" after this step, the second register is also going to be in a superposition of representing "),In=i("span"),Er=h(" for all values of "),Fn=i("span"),fa=h(" Thus, we can write its state as "),tr=i("span"),ot=S(),Qn=i("h4"),tt=h("Step 4."),Lr=S(),ce=i("p"),ma=h("Next, we measure the second register. This will make all qubits of the second register into one of the basis states randomly, and so "),nr=i("span"),qr=h(" will take on a definite value. Furthermore, the measurement will not only modify "),Xt=i("span"),rr=h(" but also "),xr=i("span"),sr=h(" because the qubits of the two registers are entangled. The value of "),Ir=i("span"),ds=h(" is a function of the value of "),bn=i("span"),so=h(" and so if we measure a particular "),or=i("span"),oo=h(" the superposition of the first register can only contains those values of "),ka=i("span"),ws=h(" that are consistent with the measurement, namely for which "),Ta=i("span"),vs=h(" So, although the measurement does not make the superposition of the first register disappear entirely, it filters it to the values of "),Rn=i("span"),bs=h(" that fulfil this criterion. And because "),pa=i("span"),gs=h(" is a repeating pattern with period "),_a=i("span"),ys=h(" those values are going to be "),Ma=i("span"),Ns=h(" apart from each other. Let the sequence "),ca=i("span"),$s=h(" denote these values. Thus, we can write the state of the first register as "),Pa=i("span"),lr=h(" where "),Br=i("span"),ur=h(" for all "),Cn=i("span"),kr=S(),Bn=i("h4"),Es=h("Step 5."),Tr=S(),it=i("p"),hr=h("Now, we apply the QFT to the first register. For a definite value of "),Dr=i("span"),yn=h(" this would yield the state "),fr=i("span"),ho=h(" But just like above, the register is in a superposition, and so the state after is going to be a linear combination of the QFT for all values of "),mr=i("span"),fo=h(": "),pr=i("span"),Sa=S(),Dn=i("h4"),mo=h("Step 6."),Mr=S(),Ne=i("p"),ks=h("We saw in the section on the QFT that for a given "),Wn=i("span"),Ts=h(" the resulting phases form a sinusoidal wave pattern with a frequency of "),zn=i("span"),Ms=h(" In this case, because of the superposition, the resulting phases are going to form a linear combination of sinusoidal wave patterns with frequencies "),jn=i("span"),Ps=h(" And this is the key to the solution, because these waves are going to "),Le(Yt.$$.fragment),po=h(" with each other in a particular way. Remember that the phases generated by the QFT were complex vectors of unit length. Now, we're adding those vectors together for "),_r=i("span"),_o=h(" and so the length of the resulting vectors will no longer be "),cr=i("span"),Ws=S(),bt=i("p"),Ur=h("Instead, at certain points (values of "),Vn=i("span"),co=h("), the waves constructively interfere, meaning their displacements sum up to a large positive or negative value, and so the measurement probabilities of those points get amplified. At other points, the displacements cancel each other out, leading to probability amplitudes near zero. If we then measure the register and read out the represented value "),Aa=i("span"),Ss=h(" it's most likely going to be one of the points of constructive interference. And the points, at which this constructive interference happens are related to the period in a special way. Namely, they are the points "),Ha=i("span"),As=h(" for "),Un=i("span"),Hs=h(" Thus, all we have to do now is measure the final state of the first register a sufficient number of times to get a statistically reliable estimation of the period.")},l($){t=l($,"H2",{});var se=u(t);r=f(se,"The period-finding problem"),se.forEach(a),s=A($),o=l($,"P",{});var nt=u(o);c=f(nt,"Recall the steps for computing the prime factors of a large integer "),_=l(nt,"SPAN",{});var qa=u(_);qa.forEach(a),b=f(nt," the hard part of which was finding the smallest "),v=l(nt,"SPAN",{});var si=u(v);si.forEach(a),w=f(nt," such that "),E=l(nt,"SPAN",{});var vo=u(E);vo.forEach(a),Q=f(nt," It turns out that "),K=l(nt,"SPAN",{});var Kr=u(K);Kr.forEach(a),L=f(nt," is a "),qe(z.$$.fragment,nt),x=f(nt," function, and below we'll show that the number "),H=l(nt,"SPAN",{});var oi=u(H);oi.forEach(a),j=f(nt," we're looking for is exactly its period."),nt.forEach(a),Y=A($),P=l($,"P",{});var Ke=u(P);re=f(Ke,"In general, the period of a function "),X=l(Ke,"SPAN",{});var js=u(X);js.forEach(a),M=f(Ke," is defined as the smallest positive number "),q=l(Ke,"SPAN",{});var bo=u(q);bo.forEach(a),B=f(Ke," for which "),R=l(Ke,"SPAN",{});var ko=u(R);ko.forEach(a),ie=f(Ke," for all "),te=l(Ke,"SPAN",{});var g=u(te);g.forEach(a),he=f(Ke," in the domain of "),Z=l(Ke,"SPAN",{});var O=u(Z);O.forEach(a),J=f(Ke," (In other words, "),de=l(Ke,"SPAN",{});var Ls=u(de);Ls.forEach(a),be=f(Ke," is a repeating sequence of the same pattern with length "),je=l(Ke,"SPAN",{});var Ft=u(je);Ft.forEach(a),ae=f(Ke,") Specifically for "),ye=l(Ke,"SPAN",{});var ii=u(ye);ii.forEach(a),we=f(Ke," because its domain is "),fe=l(Ke,"SPAN",{});var li=u(fe);li.forEach(a),ut=f(Ke," its period has to be an integer."),Ke.forEach(a),He=A($),ke=l($,"P",{});var at=u(ke);st=f(at,"Let "),Ue=l(at,"SPAN",{});var ui=u(Ue);ui.forEach(a),G=f(at," denote the period of "),pe=l(at,"SPAN",{});var hi=u(pe);hi.forEach(a),Lt=f(at," We know for sure that "),Ge=l(at,"SPAN",{});var At=u(Ge);At.forEach(a),qt=f(at," from which follows that "),Oe=l(at,"SPAN",{});var fi=u(Oe);fi.forEach(a),kn=f(at," Thus, the "),Je=l(at,"SPAN",{});var mi=u(Je);mi.forEach(a),Tn=f(at," is the smallest positive integer, for which the value of "),et=l(at,"SPAN",{});var pi=u(et);pi.forEach(a),On=f(at," equals "),Be=l(at,"SPAN",{});var _i=u(Be);_i.forEach(a),tn=f(at," Notice that this is exactly how we originally defined "),nn=l(at,"SPAN",{});var ci=u(nn);ci.forEach(a),rn=f(at," and so "),Mn=l(at,"SPAN",{});var di=u(Mn);di.forEach(a),at.forEach(a),sn=A($),Bt=l($,"P",{});var qs=u(Bt);on=f(qs,"Thus, the factoring problem can essentially be reformulated as the problem of finding the period of the function "),oe=l(qs,"SPAN",{});var mt=u(oe);mt.forEach(a),ln=f(qs," for which the quantum Fourier transform turns out to be really useful."),qs.forEach(a),ya=A($),ge=l($,"H2",{});var To=u(ge);un=f(To,"The algorithm"),To.forEach(a),Sn=A($),Kn=l($,"H4",{});var Mo=u(Kn);hn=f(Mo,"Step 1."),Mo.forEach(a),An=A($),_t=l($,"P",{});var dr=u(_t);fn=f(dr,"In order to implement Shor's algorithm, we'll need two quantum register with at least "),Dt=l(dr,"SPAN",{});var wi=u(Dt);wi.forEach(a),mn=f(dr," qubits, as that is the number of digits required to represent "),Wt=l(dr,"SPAN",{});var vi=u(Wt);vi.forEach(a),pn=f(dr," in binary notation. (In case "),zt=l(dr,"SPAN",{});var bi=u(zt);bi.forEach(a),_n=f(dr," is not an integer, we have to round it up.) Note that this is a lower limit, and the more qubits we use, the faster we'll find the solution."),dr.forEach(a),Hn=A($),ht=l($,"P",{});var xa=u(ht);cn=f(xa,"Let "),jt=l(xa,"SPAN",{});var da=u(jt);da.forEach(a),dn=f(xa," denote the number of qubits we chose to construct the both registers, and "),Vt=l(xa,"SPAN",{});var gi=u(Vt);gi.forEach(a),wn=f(xa," the current state of the two registers. Let's ignore the second register for now, and start with all qubits of the first register being in the basis state "),Ut=l(xa,"SPAN",{});var yi=u(Ut);yi.forEach(a),xt=f(xa," thus we can write its state as "),Et=l(xa,"SPAN",{});var Ni=u(Et);Ni.forEach(a),xa.forEach(a),Ca=A($),kt=l($,"H4",{});var Po=u(kt);Zn=f(Po,"Step 2."),Po.forEach(a),Ba=A($),Ze=l($,"P",{});var Me=u(Ze);Tt=f(Me,"Next, we apply the so called "),Xn=l(Me,"SPAN",{});var $i=u(Xn);$i.forEach(a),ft=f(Me," (Hadamard) gate to each qubit of the first register, in order to set them into an equal superposition of the two basis states. This means the state of the register is now "),Yn=l(Me,"SPAN",{});var Ei=u(Yn);Ei.forEach(a),ea=f(Me," We can factor out the "),ta=l(Me,"SPAN",{});var ki=u(ta);ki.forEach(a),Gt=f(Me," terms to obtain "),Xe=l(Me,"SPAN",{});var Ti=u(Xe);Ti.forEach(a),Me.forEach(a),It=A($),Ae=l($,"P",{});var Ht=u(Ae);Na=f(Ht,"Let "),ct=l(Ht,"SPAN",{});var Mi=u(ct);Mi.forEach(a),$a=f(Ht," denote the number represented by the qubits of the first register (that is, the number we get if we read out the state as a sequence of binary digits). As we already saw in the case of the QFT, each qubit being in an equal superposition of the two basis states translates to the entire register being in the superposition of all combinations of these basis states, and consequently "),wt=l(Ht,"SPAN",{});var Pi=u(wt);Pi.forEach(a),vn=f(Ht," being in the superposition of all values from "),Ot=l(Ht,"SPAN",{});var Si=u(Ot);Si.forEach(a),me=f(Ht," to "),Mt=l(Ht,"SPAN",{});var Ai=u(Mt);Ai.forEach(a),gr=f(Ht," Let's express the state as the superposition of these values: "),Pt=l(Ht,"SPAN",{});var Hi=u(Pt);Hi.forEach(a),yr=f(Ht," Thus, if we now measure the entire register and read out "),Kt=l(Ht,"SPAN",{});var Li=u(Kt);Li.forEach(a),Sr=f(Ht," we're going to get each possible value with an equal probability of "),ue=l(Ht,"SPAN",{});var So=u(ue);So.forEach(a),Ht.forEach(a),aa=A($),Ye=l($,"H4",{});var xs=u(Ye);Ln=f(xs,"Step 3."),xs.forEach(a),De=A($),Fe=l($,"P",{});var rt=u(Fe);ra=f(rt,"This is the point where the second register enters the picture. We begin with all qubits of this register being in the basis state "),Ua=l(rt,"SPAN",{});var Ao=u(Ua);Ao.forEach(a),sa=f(rt," so "),Ga=l(rt,"SPAN",{});var qi=u(Ga);qi.forEach(a),oa=f(rt," Let "),Ea=l(rt,"SPAN",{});var Vs=u(Ea);Vs.forEach(a),ia=f(rt," denote the number represented by the second register, analogously to "),Oa=l(rt,"SPAN",{});var xi=u(Oa);xi.forEach(a),la=f(rt," Next, we apply a combination of gates to entangle the qubits of the two registers in a special way, in order to implement the function "),Ka=l(rt,"SPAN",{});var Ho=u(Ka);Ho.forEach(a),Ce=f(rt," To see what this means, let's take a step back and assume all qubits of the first register are in one particular basis state, and so "),Za=l(rt,"SPAN",{});var Ii=u(Za);Ii.forEach(a),ua=f(rt," is a definite value between "),Xa=l(rt,"SPAN",{});var $e=u(Xa);$e.forEach(a),ha=f(rt," and "),Ya=l(rt,"SPAN",{});var Fi=u(Ya);Fi.forEach(a),qn=f(rt," instead of a superposition of values. If we now applied the current step of the algorithm to the registers, it would set "),_e=l(rt,"SPAN",{});var Qi=u(_e);Qi.forEach(a),rt.forEach(a),xn=A($),St=l($,"P",{});var Ia=u(St);Nr=f(Ia,"But because in our case the first register is actually in a superposition of all possible values of "),Zt=l(Ia,"SPAN",{});var Ri=u(Zt);Ri.forEach(a),$r=f(Ia," after this step, the second register is also going to be in a superposition of representing "),In=l(Ia,"SPAN",{});var Ci=u(In);Ci.forEach(a),Er=f(Ia," for all values of "),Fn=l(Ia,"SPAN",{});var Bi=u(Fn);Bi.forEach(a),fa=f(Ia," Thus, we can write its state as "),tr=l(Ia,"SPAN",{});var Di=u(tr);Di.forEach(a),Ia.forEach(a),ot=A($),Qn=l($,"H4",{});var Lo=u(Qn);tt=f(Lo,"Step 4."),Lo.forEach(a),Lr=A($),ce=l($,"P",{});var Te=u(ce);ma=f(Te,"Next, we measure the second register. This will make all qubits of the second register into one of the basis states randomly, and so "),nr=l(Te,"SPAN",{});var Wi=u(nr);Wi.forEach(a),qr=f(Te," will take on a definite value. Furthermore, the measurement will not only modify "),Xt=l(Te,"SPAN",{});var zi=u(Xt);zi.forEach(a),rr=f(Te," but also "),xr=l(Te,"SPAN",{});var ji=u(xr);ji.forEach(a),sr=f(Te," because the qubits of the two registers are entangled. The value of "),Ir=l(Te,"SPAN",{});var Vi=u(Ir);Vi.forEach(a),ds=f(Te," is a function of the value of "),bn=l(Te,"SPAN",{});var Ui=u(bn);Ui.forEach(a),so=f(Te," and so if we measure a particular "),or=l(Te,"SPAN",{});var Gi=u(or);Gi.forEach(a),oo=f(Te," the superposition of the first register can only contains those values of "),ka=l(Te,"SPAN",{});var Oi=u(ka);Oi.forEach(a),ws=f(Te," that are consistent with the measurement, namely for which "),Ta=l(Te,"SPAN",{});var qo=u(Ta);qo.forEach(a),vs=f(Te," So, although the measurement does not make the superposition of the first register disappear entirely, it filters it to the values of "),Rn=l(Te,"SPAN",{});var xo=u(Rn);xo.forEach(a),bs=f(Te," that fulfil this criterion. And because "),pa=l(Te,"SPAN",{});var Ki=u(pa);Ki.forEach(a),gs=f(Te," is a repeating pattern with period "),_a=l(Te,"SPAN",{});var Zr=u(_a);Zr.forEach(a),ys=f(Te," those values are going to be "),Ma=l(Te,"SPAN",{});var Zi=u(Ma);Zi.forEach(a),Ns=f(Te," apart from each other. Let the sequence "),ca=l(Te,"SPAN",{});var Xi=u(ca);Xi.forEach(a),$s=f(Te," denote these values. Thus, we can write the state of the first register as "),Pa=l(Te,"SPAN",{});var Us=u(Pa);Us.forEach(a),lr=f(Te," where "),Br=l(Te,"SPAN",{});var Is=u(Br);Is.forEach(a),ur=f(Te," for all "),Cn=l(Te,"SPAN",{});var Yi=u(Cn);Yi.forEach(a),Te.forEach(a),kr=A($),Bn=l($,"H4",{});var Io=u(Bn);Es=f(Io,"Step 5."),Io.forEach(a),Tr=A($),it=l($,"P",{});var Nn=u(it);hr=f(Nn,"Now, we apply the QFT to the first register. For a definite value of "),Dr=l(Nn,"SPAN",{});var Ji=u(Dr);Ji.forEach(a),yn=f(Nn," this would yield the state "),fr=l(Nn,"SPAN",{});var el=u(fr);el.forEach(a),ho=f(Nn," But just like above, the register is in a superposition, and so the state after is going to be a linear combination of the QFT for all values of "),mr=l(Nn,"SPAN",{});var Fo=u(mr);Fo.forEach(a),fo=f(Nn,": "),pr=l(Nn,"SPAN",{});var wr=u(pr);wr.forEach(a),Nn.forEach(a),Sa=A($),Dn=l($,"H4",{});var Qo=u(Dn);mo=f(Qo,"Step 6."),Qo.forEach(a),Mr=A($),Ne=l($,"P",{});var Qt=u(Ne);ks=f(Qt,"We saw in the section on the QFT that for a given "),Wn=l(Qt,"SPAN",{});var Ro=u(Wn);Ro.forEach(a),Ts=f(Qt," the resulting phases form a sinusoidal wave pattern with a frequency of "),zn=l(Qt,"SPAN",{});var Gs=u(zn);Gs.forEach(a),Ms=f(Qt," In this case, because of the superposition, the resulting phases are going to form a linear combination of sinusoidal wave patterns with frequencies "),jn=l(Qt,"SPAN",{});var Co=u(jn);Co.forEach(a),Ps=f(Qt," And this is the key to the solution, because these waves are going to "),qe(Yt.$$.fragment,Qt),po=f(Qt," with each other in a particular way. Remember that the phases generated by the QFT were complex vectors of unit length. Now, we're adding those vectors together for "),_r=l(Qt,"SPAN",{});var Bo=u(_r);Bo.forEach(a),_o=f(Qt," and so the length of the resulting vectors will no longer be "),cr=l(Qt,"SPAN",{});var tl=u(cr);tl.forEach(a),Qt.forEach(a),Ws=A($),bt=l($,"P",{});var Gn=u(bt);Ur=f(Gn,"Instead, at certain points (values of "),Vn=l(Gn,"SPAN",{});var nl=u(Vn);nl.forEach(a),co=f(Gn,"), the waves constructively interfere, meaning their displacements sum up to a large positive or negative value, and so the measurement probabilities of those points get amplified. At other points, the displacements cancel each other out, leading to probability amplitudes near zero. If we then measure the register and read out the represented value "),Aa=l(Gn,"SPAN",{});var Do=u(Aa);Do.forEach(a),Ss=f(Gn," it's most likely going to be one of the points of constructive interference. And the points, at which this constructive interference happens are related to the period in a special way. Namely, they are the points "),Ha=l(Gn,"SPAN",{});var Wo=u(Ha);Wo.forEach(a),As=f(Gn," for "),Un=l(Gn,"SPAN",{});var al=u(Un);al.forEach(a),Hs=f(Gn," Thus, all we have to do now is measure the final state of the first register a sufficient number of times to get a statistically reliable estimation of the period."),Gn.forEach(a)},m($,se){y($,t,se),n(t,r),y($,s,se),y($,o,se),n(o,c),n(o,_),_.innerHTML=m,n(o,b),n(o,v),v.innerHTML=k,n(o,w),n(o,E),E.innerHTML=N,n(o,Q),n(o,K),K.innerHTML=V,n(o,L),xe(z,o,null),n(o,x),n(o,H),H.innerHTML=I,n(o,j),y($,Y,se),y($,P,se),n(P,re),n(P,X),X.innerHTML=D,n(P,M),n(P,q),q.innerHTML=ee,n(P,B),n(P,R),R.innerHTML=U,n(P,ie),n(P,te),te.innerHTML=Ee,n(P,he),n(P,Z),Z.innerHTML=T,n(P,J),n(P,de),de.innerHTML=We,n(P,be),n(P,je),je.innerHTML=ne,n(P,ae),n(P,ye),ye.innerHTML=lt,n(P,we),n(P,fe),fe.innerHTML=Ve,n(P,ut),y($,He,se),y($,ke,se),n(ke,st),n(ke,Ue),Ue.innerHTML=yt,n(ke,G),n(ke,pe),pe.innerHTML=le,n(ke,Lt),n(ke,Ge),Ge.innerHTML=Nt,n(ke,qt),n(ke,Oe),Oe.innerHTML=$t,n(ke,kn),n(ke,Je),Je.innerHTML=Jt,n(ke,Tn),n(ke,et),et.innerHTML=pt,n(ke,On),n(ke,Be),Be.innerHTML=en,n(ke,tn),n(ke,nn),nn.innerHTML=an,n(ke,rn),n(ke,Mn),Mn.innerHTML=Pn,y($,sn,se),y($,Bt,se),n(Bt,on),n(Bt,oe),oe.innerHTML=ts,n(Bt,ln),y($,ya,se),y($,ge,se),n(ge,un),y($,Sn,se),y($,Kn,se),n(Kn,hn),y($,An,se),y($,_t,se),n(_t,fn),n(_t,Dt),Dt.innerHTML=ns,n(_t,mn),n(_t,Wt),Wt.innerHTML=as,n(_t,pn),n(_t,zt),zt.innerHTML=rs,n(_t,_n),y($,Hn,se),y($,ht,se),n(ht,cn),n(ht,jt),jt.innerHTML=ss,n(ht,dn),n(ht,Vt),Vt.innerHTML=os,n(ht,wn),n(ht,Ut),Ut.innerHTML=is,n(ht,xt),n(ht,Et),Et.innerHTML=Ra,y($,Ca,se),y($,kt,se),n(kt,Zn),y($,Ba,se),y($,Ze,se),n(Ze,Tt),n(Ze,Xn),Xn.innerHTML=Da,n(Ze,ft),n(Ze,Yn),Yn.innerHTML=Jn,n(Ze,ea),n(Ze,ta),ta.innerHTML=Wa,n(Ze,Gt),n(Ze,Xe),Xe.innerHTML=ls,y($,It,se),y($,Ae,se),n(Ae,Na),n(Ae,ct),ct.innerHTML=dt,n(Ae,$a),n(Ae,wt),wt.innerHTML=za,n(Ae,vn),n(Ae,Ot),Ot.innerHTML=Pr,n(Ae,me),n(Ae,Mt),Mt.innerHTML=ja,n(Ae,gr),n(Ae,Pt),Pt.innerHTML=Va,n(Ae,yr),n(Ae,Kt),Kt.innerHTML=na,n(Ae,Sr),n(Ae,ue),ue.innerHTML=ze,y($,aa,se),y($,Ye,se),n(Ye,Ln),y($,De,se),y($,Fe,se),n(Fe,ra),n(Fe,Ua),Ua.innerHTML=us,n(Fe,sa),n(Fe,Ga),Ga.innerHTML=hs,n(Fe,oa),n(Fe,Ea),Ea.innerHTML=vt,n(Fe,ia),n(Fe,Oa),Oa.innerHTML=fs,n(Fe,la),n(Fe,Ka),Ka.innerHTML=Ar,n(Fe,Ce),n(Fe,Za),Za.innerHTML=ms,n(Fe,ua),n(Fe,Xa),Xa.innerHTML=ps,n(Fe,ha),n(Fe,Ya),Ya.innerHTML=_s,n(Fe,qn),n(Fe,_e),_e.innerHTML=cs,y($,xn,se),y($,St,se),n(St,Nr),n(St,Zt),Zt.innerHTML=to,n(St,$r),n(St,In),In.innerHTML=Ja,n(St,Er),n(St,Fn),Fn.innerHTML=er,n(St,fa),n(St,tr),tr.innerHTML=Hr,y($,ot,se),y($,Qn,se),n(Qn,tt),y($,Lr,se),y($,ce,se),n(ce,ma),n(ce,nr),nr.innerHTML=no,n(ce,qr),n(ce,Xt),Xt.innerHTML=ar,n(ce,rr),n(ce,xr),xr.innerHTML=ao,n(ce,sr),n(ce,Ir),Ir.innerHTML=ro,n(ce,ds),n(ce,bn),bn.innerHTML=Fr,n(ce,so),n(ce,or),or.innerHTML=Qr,n(ce,oo),n(ce,ka),ka.innerHTML=Rr,n(ce,ws),n(ce,Ta),Ta.innerHTML=gn,n(ce,vs),n(ce,Rn),Rn.innerHTML=Jo,n(ce,bs),n(ce,pa),pa.innerHTML=io,n(ce,gs),n(ce,_a),_a.innerHTML=lo,n(ce,ys),n(ce,Ma),Ma.innerHTML=ir,n(ce,Ns),n(ce,ca),ca.innerHTML=uo,n(ce,$s),n(ce,Pa),Pa.innerHTML=Cr,n(ce,lr),n(ce,Br),Br.innerHTML=Cs,n(ce,ur),n(ce,Cn),Cn.innerHTML=ei,y($,kr,se),y($,Bn,se),n(Bn,Es),y($,Tr,se),y($,it,se),n(it,hr),n(it,Dr),Dr.innerHTML=Bs,n(it,yn),n(it,fr),fr.innerHTML=Wr,n(it,ho),n(it,mr),mr.innerHTML=zr,n(it,fo),n(it,pr),pr.innerHTML=Ds,y($,Sa,se),y($,Dn,se),n(Dn,mo),y($,Mr,se),y($,Ne,se),n(Ne,ks),n(Ne,Wn),Wn.innerHTML=ti,n(Ne,Ts),n(Ne,zn),zn.innerHTML=ni,n(Ne,Ms),n(Ne,jn),jn.innerHTML=ai,n(Ne,Ps),xe(Yt,Ne,null),n(Ne,po),n(Ne,_r),_r.innerHTML=jr,n(Ne,_o),n(Ne,cr),cr.innerHTML=Vr,y($,Ws,se),y($,bt,se),n(bt,Ur),n(bt,Vn),Vn.innerHTML=Gr,n(bt,co),n(bt,Aa),Aa.innerHTML=Or,n(bt,Ss),n(bt,Ha),Ha.innerHTML=gt,n(bt,As),n(bt,Un),Un.innerHTML=ri,n(bt,Hs),La=!0,wo||(zs=[d(_,"mouseenter",e[0]),d(v,"mouseenter",e[1]),d(E,"mouseenter",e[2]),d(K,"mouseenter",e[3]),d(H,"mouseenter",e[4]),d(X,"mouseenter",e[5]),d(q,"mouseenter",e[6]),d(R,"mouseenter",e[7]),d(te,"mouseenter",e[8]),d(Z,"mouseenter",e[9]),d(de,"mouseenter",e[10]),d(je,"mouseenter",e[11]),d(ye,"mouseenter",e[12]),d(fe,"mouseenter",e[13]),d(Ue,"mouseenter",e[14]),d(pe,"mouseenter",e[15]),d(Ge,"mouseenter",e[16]),d(Oe,"mouseenter",e[17]),d(Je,"mouseenter",e[18]),d(et,"mouseenter",e[19]),d(Be,"mouseenter",e[20]),d(nn,"mouseenter",e[21]),d(Mn,"mouseenter",e[22]),d(oe,"mouseenter",e[23]),d(Dt,"mouseenter",e[24]),d(Wt,"mouseenter",e[25]),d(zt,"mouseenter",e[26]),d(jt,"mouseenter",e[27]),d(Vt,"mouseenter",e[28]),d(Ut,"mouseenter",e[29]),d(Et,"mouseenter",e[30]),d(Xn,"mouseenter",e[31]),d(Yn,"mouseenter",e[32]),d(ta,"mouseenter",e[33]),d(Xe,"mouseenter",e[34]),d(ct,"mouseenter",e[35]),d(wt,"mouseenter",e[36]),d(Ot,"mouseenter",e[37]),d(Mt,"mouseenter",e[38]),d(Pt,"mouseenter",e[39]),d(Kt,"mouseenter",e[40]),d(ue,"mouseenter",e[41]),d(Ua,"mouseenter",e[42]),d(Ga,"mouseenter",e[43]),d(Ea,"mouseenter",e[44]),d(Oa,"mouseenter",e[45]),d(Ka,"mouseenter",e[46]),d(Za,"mouseenter",e[47]),d(Xa,"mouseenter",e[48]),d(Ya,"mouseenter",e[49]),d(_e,"mouseenter",e[50]),d(Zt,"mouseenter",e[51]),d(In,"mouseenter",e[52]),d(Fn,"mouseenter",e[53]),d(tr,"mouseenter",e[54]),d(nr,"mouseenter",e[55]),d(Xt,"mouseenter",e[56]),d(xr,"mouseenter",e[57]),d(Ir,"mouseenter",e[58]),d(bn,"mouseenter",e[59]),d(or,"mouseenter",e[60]),d(ka,"mouseenter",e[61]),d(Ta,"mouseenter",e[62]),d(Rn,"mouseenter",e[63]),d(pa,"mouseenter",e[64]),d(_a,"mouseenter",e[65]),d(Ma,"mouseenter",e[66]),d(ca,"mouseenter",e[67]),d(Pa,"mouseenter",e[68]),d(Br,"mouseenter",e[69]),d(Cn,"mouseenter",e[70]),d(Dr,"mouseenter",e[71]),d(fr,"mouseenter",e[72]),d(mr,"mouseenter",e[73]),d(pr,"mouseenter",e[74]),d(Wn,"mouseenter",e[75]),d(zn,"mouseenter",e[76]),d(jn,"mouseenter",e[77]),d(_r,"mouseenter",e[78]),d(cr,"mouseenter",e[79]),d(Vn,"mouseenter",e[80]),d(Aa,"mouseenter",e[81]),d(Ha,"mouseenter",e[82]),d(Un,"mouseenter",e[83])],wo=!0)},p($,se){const nt={};se[2]&4194304&&(nt.$$scope={dirty:se,ctx:$}),z.$set(nt);const qa={};se[2]&4194304&&(qa.$$scope={dirty:se,ctx:$}),Yt.$set(qa)},i($){La||(Pe(z.$$.fragment,$),Pe(Yt.$$.fragment,$),La=!0)},o($){Se(z.$$.fragment,$),Se(Yt.$$.fragment,$),La=!1},d($){$&&a(t),$&&a(s),$&&a(o),Ie(z),$&&a(Y),$&&a(P),$&&a(He),$&&a(ke),$&&a(sn),$&&a(Bt),$&&a(ya),$&&a(ge),$&&a(Sn),$&&a(Kn),$&&a(An),$&&a(_t),$&&a(Hn),$&&a(ht),$&&a(Ca),$&&a(kt),$&&a(Ba),$&&a(Ze),$&&a(It),$&&a(Ae),$&&a(aa),$&&a(Ye),$&&a(De),$&&a(Fe),$&&a(xn),$&&a(St),$&&a(ot),$&&a(Qn),$&&a(Lr),$&&a(ce),$&&a(kr),$&&a(Bn),$&&a(Tr),$&&a(it),$&&a(Sa),$&&a(Dn),$&&a(Mr),$&&a(Ne),Ie(Yt),$&&a(Ws),$&&a(bt),wo=!1,es(zs)}}}function C(e){console.log(e)}function Zf(e){return[()=>C(["N"]),()=>C(["N","r"]),()=>C(["f","a","N","r"]),()=>C(["f","a","N"]),()=>C(["r"]),()=>C(["g"]),()=>C(["p"]),()=>C(["x","p","g"]),()=>C(["x"]),()=>C(["g"]),()=>C(["g"]),()=>C(["p"]),()=>C(["f","a","N"]),()=>C(["N"]),()=>C(["p","N"]),()=>C(["f","a","N"]),()=>C(["f","a","N"]),()=>C(["f","a","N","p"]),()=>C(["p"]),()=>C(["f","a","N"]),()=>C([]),()=>C(["r"]),()=>C(["p","r"]),()=>C(["f","a","N"]),()=>C(["N"]),()=>C(["N"]),()=>C(["N"]),()=>C(["N","n"]),()=>C(["\\psi"]),()=>C([]),()=>C(["m","t","s","\\psi","r","n"]),()=>C(["H"]),()=>C(["m","t","s","\\psi","r","n"]),()=>C([]),()=>C(["\\psi","n"]),()=>C(["x"]),()=>C(["x"]),()=>C([]),()=>C(["n"]),()=>C(["x","\\psi","n"]),()=>C(["x"]),()=>C(["n"]),()=>C([]),()=>C(["m","t","s","\\psi","r","n"]),()=>C(["y"]),()=>C(["x"]),()=>C(["f","a","N","x"]),()=>C(["x"]),()=>C([]),()=>C(["n"]),()=>C(["x","a","N","y"]),()=>C(["x"]),()=>C(["x","a","N","y"]),()=>C(["x"]),()=>C(["y","x","a","N","\\psi","n"]),()=>C(["y"]),()=>C(["\\psi"]),()=>C(["\\psi"]),()=>C(["y"]),()=>C(["x"]),()=>C(["y"]),()=>C(["x"]),()=>C(["x","a","N","y"]),()=>C(["x"]),()=>C(["f","a","N"]),()=>C(["p"]),()=>C(["p"]),()=>C(["x","n","k"]),()=>C(["x","\\psi","k"]),()=>C(["x","p"]),()=>C(["k"]),()=>C(["x"]),()=>C(["y","\\psi","n","x"]),()=>C(["x"]),()=>C(["y","k","x","\\psi","n"]),()=>C(["x"]),()=>C(["x"]),()=>C(["x","k"]),()=>C(["x","k"]),()=>C([]),()=>C(["x"]),()=>C(["x"]),()=>C(["N","p","j"]),()=>C(["p","j"])]}class Xf extends va{constructor(t){super(),ba(this,t,Zf,Kf,ga,{},null,[-1,-1,-1])}}function Yf(e){let t,r,s,o,c;return o=new Xf({}),{c(){t=i("h2"),r=h("Shor's Algorithm"),s=S(),Le(o.$$.fragment)},l(_){t=l(_,"H2",{});var m=u(t);r=f(m,"Shor's Algorithm"),m.forEach(a),s=A(_),qe(o.$$.fragment,_)},m(_,m){y(_,t,m),n(t,r),y(_,s,m),xe(o,_,m),c=!0},p:Js,i(_){c||(Pe(o.$$.fragment,_),c=!0)},o(_){Se(o.$$.fragment,_),c=!1},d(_){_&&a(t),_&&a(s),Ie(o,_)}}}class Jf extends va{constructor(t){super(),ba(this,t,null,Yf,ga,{})}}function em(e){let t,r,s,o,c,_,m,b,v,k,w,E,N,Q,K,V,L,z,x,H;return N=new ph({}),K=new jf({}),L=new Lf({}),x=new Jf({}),{c(){t=i("div"),r=S(),s=i("main"),o=i("h1"),c=h("Interactive Quantum Computing"),_=S(),m=i("p"),b=h("This page intends to introduce concepts, connect them and derive a practical use case"),v=S(),k=i("h2"),w=h("Clickable Table of Contents"),E=S(),Le(N.$$.fragment),Q=S(),Le(K.$$.fragment),V=S(),Le(L.$$.fragment),z=S(),Le(x.$$.fragment),this.h()},l(I){t=l(I,"DIV",{class:!0}),u(t).forEach(a),r=A(I),s=l(I,"MAIN",{});var j=u(s);o=l(j,"H1",{});var Y=u(o);c=f(Y,"Interactive Quantum Computing"),Y.forEach(a),_=A(j),m=l(j,"P",{});var P=u(m);b=f(P,"This page intends to introduce concepts, connect them and derive a practical use case"),P.forEach(a),v=A(j),k=l(j,"H2",{});var re=u(k);w=f(re,"Clickable Table of Contents"),re.forEach(a),E=A(j),qe(N.$$.fragment,j),Q=A(j),qe(K.$$.fragment,j),V=A(j),qe(L.$$.fragment,j),z=A(j),qe(x.$$.fragment,j),j.forEach(a),this.h()},h(){F(t,"class","sidebar")},m(I,j){y(I,t,j),y(I,r,j),y(I,s,j),n(s,o),n(o,c),n(s,_),n(s,m),n(m,b),n(s,v),n(s,k),n(k,w),n(s,E),xe(N,s,null),n(s,Q),xe(K,s,null),n(s,V),xe(L,s,null),n(s,z),xe(x,s,null),H=!0},p:Js,i(I){H||(Pe(N.$$.fragment,I),Pe(K.$$.fragment,I),Pe(L.$$.fragment,I),Pe(x.$$.fragment,I),H=!0)},o(I){Se(N.$$.fragment,I),Se(K.$$.fragment,I),Se(L.$$.fragment,I),Se(x.$$.fragment,I),H=!1},d(I){I&&a(t),I&&a(r),I&&a(s),Ie(N),Ie(K),Ie(L),Ie(x)}}}const sm=!0;class om extends va{constructor(t){super(),ba(this,t,null,em,ga,{})}}export{om as default,sm as prerender};
